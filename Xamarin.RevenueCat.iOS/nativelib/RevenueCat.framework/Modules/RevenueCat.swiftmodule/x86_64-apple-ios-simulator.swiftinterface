// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.8.1 (swiftlang-5.8.0.124.5 clang-1403.0.22.11.100)
// swift-module-flags: -target x86_64-apple-ios11.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name RevenueCat
// swift-module-flags-ignorable: -enable-bare-slash-regex
import AdServices
import CommonCrypto
import CryptoKit
import Foundation
@_exported import RevenueCat
import StoreKit
import Swift
import SwiftUI
import UIKit
import _Concurrency
import _StoreKit_SwiftUI
import _StringProcessing
import os
@objc(RCOffering) final public class Offering : ObjectiveC.NSObject {
  @objc final public let identifier: Swift.String
  @objc final public let serverDescription: Swift.String
  @objc final public var metadata: [Swift.String : Any] {
    @objc get
  }
  final public let paywall: RevenueCat.PaywallData?
  @objc final public let availablePackages: [RevenueCat.Package]
  @objc final public let lifetime: RevenueCat.Package?
  @objc final public let annual: RevenueCat.Package?
  @objc final public let sixMonth: RevenueCat.Package?
  @objc final public let threeMonth: RevenueCat.Package?
  @objc final public let twoMonth: RevenueCat.Package?
  @objc final public let monthly: RevenueCat.Package?
  @objc final public let weekly: RevenueCat.Package?
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc final public func package(identifier: Swift.String?) -> RevenueCat.Package?
  @objc final public subscript(key: Swift.String) -> RevenueCat.Package? {
    @objc get
  }
  @objc convenience public init(identifier: Swift.String, serverDescription: Swift.String, metadata: [Swift.String : Any] = [:], availablePackages: [RevenueCat.Package])
  public init(identifier: Swift.String, serverDescription: Swift.String, metadata: [Swift.String : Any] = [:], paywall: RevenueCat.PaywallData? = nil, availablePackages: [RevenueCat.Package])
  @objc deinit
}
extension RevenueCat.Offering {
  final public func getMetadataValue<T>(for key: Swift.String, default: T) -> T
}
extension RevenueCat.Offering : Swift.Identifiable {
  final public var id: Swift.String {
    get
  }
  public typealias ID = Swift.String
}
extension RevenueCat.Offering : Swift.Sendable {
}
public enum PaywallEvent {
  public typealias ID = Foundation.UUID
  public typealias SessionID = Foundation.UUID
  case impression(RevenueCat.PaywallEvent.CreationData, RevenueCat.PaywallEvent.Data)
  case cancel(RevenueCat.PaywallEvent.CreationData, RevenueCat.PaywallEvent.Data)
  case close(RevenueCat.PaywallEvent.CreationData, RevenueCat.PaywallEvent.Data)
}
extension RevenueCat.PaywallEvent {
  public struct CreationData {
    public var id: RevenueCat.PaywallEvent.ID
    public var date: Foundation.Date
    public init(id: RevenueCat.PaywallEvent.ID = .init(), date: Foundation.Date = .init())
  }
}
extension RevenueCat.PaywallEvent {
  public struct Data {
    public var offeringIdentifier: Swift.String
    public var paywallRevision: Swift.Int
    public var sessionIdentifier: RevenueCat.PaywallEvent.SessionID
    public var displayMode: RevenueCat.PaywallViewMode
    public var localeIdentifier: Swift.String
    public var darkMode: Swift.Bool
    @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
    public init(offering: RevenueCat.Offering, paywall: RevenueCat.PaywallData, sessionID: RevenueCat.PaywallEvent.SessionID, displayMode: RevenueCat.PaywallViewMode, locale: Foundation.Locale, darkMode: Swift.Bool)
  }
}
extension RevenueCat.PaywallEvent {
  public var creationData: RevenueCat.PaywallEvent.CreationData {
    get
  }
  public var data: RevenueCat.PaywallEvent.Data {
    get
  }
}
extension RevenueCat.PaywallEvent.CreationData : Swift.Equatable, Swift.Codable, Swift.Sendable {
  public static func == (a: RevenueCat.PaywallEvent.CreationData, b: RevenueCat.PaywallEvent.CreationData) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.PaywallEvent.Data : Swift.Equatable, Swift.Codable, Swift.Sendable {
  public static func == (a: RevenueCat.PaywallEvent.Data, b: RevenueCat.PaywallEvent.Data) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.PaywallEvent : Swift.Equatable, Swift.Codable, Swift.Sendable {
  public static func == (a: RevenueCat.PaywallEvent, b: RevenueCat.PaywallEvent) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
infix operator ??? : DefaultPrecedence
@_hasMissingDesignatedInitializers @objc(RCOfferings) final public class Offerings : ObjectiveC.NSObject {
  @objc final public let all: [Swift.String : RevenueCat.Offering]
  @objc final public var current: RevenueCat.Offering? {
    @objc get
  }
  @objc deinit
}
extension RevenueCat.Offerings : Swift.Sendable {
}
extension RevenueCat.Offerings {
  @objc final public func offering(identifier: Swift.String?) -> RevenueCat.Offering?
  @objc final public subscript(key: Swift.String) -> RevenueCat.Offering? {
    @objc get
  }
  @objc override final public var description: Swift.String {
    @objc get
  }
}
extension RevenueCat.Purchases {
  @available(iOS 15.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  final public func beginRefundRequest(forProduct productID: Swift.String, completion: @escaping (Swift.Result<RevenueCat.RefundRequestStatus, RevenueCat.PublicError>) -> Swift.Void)
  @available(iOS 15.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  final public func beginRefundRequest(forEntitlement entitlementID: Swift.String, completion: @escaping (Swift.Result<RevenueCat.RefundRequestStatus, RevenueCat.PublicError>) -> Swift.Void)
  @available(iOS 15.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  final public func beginRefundRequestForActiveEntitlement(completion: @escaping (Swift.Result<RevenueCat.RefundRequestStatus, RevenueCat.PublicError>) -> Swift.Void)
  @available(iOS 16.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  final public func showStoreMessages(for types: Swift.Set<RevenueCat.StoreMessageType> = Set(StoreMessageType.allCases), completion: @escaping () -> Swift.Void)
}
@_hasMissingDesignatedInitializers @objc(RCStorefront) final public class Storefront : ObjectiveC.NSObject {
  @objc final public var countryCode: Swift.String {
    @objc get
  }
  @objc final public var identifier: Swift.String {
    @objc get
  }
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  @objc override final public var hash: Swift.Int {
    @objc get
  }
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc deinit
}
extension RevenueCat.Storefront : Swift.Sendable {
}
extension RevenueCat.Storefront {
  #if compiler(>=5.3) && $EffectfulProp
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, macCatalyst 13.1, *)
  public static var currentStorefront: RevenueCat.Storefront? {
    get async
  }
  #endif
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, macCatalyst 13.1, *)
  @available(swift, obsoleted: 0.0.1, renamed: "currentStorefront")
  @objc public static var sk1CurrentStorefront: RevenueCat.Storefront? {
    @objc get
  }
}
extension RevenueCat.Storefront {
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, macCatalyst 13.1, *)
  @objc final public var sk1Storefront: StoreKit.SKStorefront? {
    @objc get
  }
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  final public var sk2Storefront: StoreKit.Storefront? {
    get
  }
}
@objc(RCVerificationResult) public enum VerificationResult : Swift.Int {
  case notRequested = 0
  case verified = 1
  case verifiedOnDevice = 3
  case failed = 2
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension RevenueCat.VerificationResult : Swift.Sendable, Swift.Codable {
}
extension RevenueCat.VerificationResult {
  public var isVerified: Swift.Bool {
    get
  }
}
extension RevenueCat.VerificationResult : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers @objc(RCAttribution) final public class Attribution : ObjectiveC.NSObject {
  @objc deinit
}
@available(iOS 14.3, macOS 11.1, macCatalyst 14.3, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension RevenueCat.Attribution {
  @objc final public func enableAdServicesAttributionTokenCollection()
}
extension RevenueCat.Attribution {
  @objc final public func collectDeviceIdentifiers()
  @objc final public func setAttributes(_ attributes: [Swift.String : Swift.String])
  @objc final public func setEmail(_ email: Swift.String?)
  @objc final public func setPhoneNumber(_ phoneNumber: Swift.String?)
  @objc final public func setDisplayName(_ displayName: Swift.String?)
  @objc final public func setPushToken(_ pushToken: Foundation.Data?)
  @objc final public func setPushTokenString(_ pushToken: Swift.String?)
  @objc final public func setAdjustID(_ adjustID: Swift.String?)
  @objc final public func setAppsflyerID(_ appsflyerID: Swift.String?)
  @objc final public func setFBAnonymousID(_ fbAnonymousID: Swift.String?)
  @objc final public func setMparticleID(_ mparticleID: Swift.String?)
  @objc final public func setOnesignalID(_ onesignalID: Swift.String?)
  @objc final public func setOnesignalUserID(_ onesignalUserID: Swift.String?)
  @objc final public func setAirshipChannelID(_ airshipChannelID: Swift.String?)
  @objc final public func setCleverTapID(_ cleverTapID: Swift.String?)
  @objc final public func setMixpanelDistinctID(_ mixpanelDistinctID: Swift.String?)
  @objc final public func setFirebaseAppInstanceID(_ firebaseAppInstanceID: Swift.String?)
  @objc final public func setMediaSource(_ mediaSource: Swift.String?)
  @objc final public func setCampaign(_ campaign: Swift.String?)
  @objc final public func setAdGroup(_ adGroup: Swift.String?)
  @objc final public func setAd(_ installAd: Swift.String?)
  @objc final public func setKeyword(_ keyword: Swift.String?)
  @objc final public func setCreative(_ creative: Swift.String?)
}
extension RevenueCat.Attribution : @unchecked Swift.Sendable {
}
extension RevenueCat.StoreProduct {
  @objc(RCStoreProductCategory) public enum ProductCategory : Swift.Int {
    case subscription
    case nonSubscription
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc(RCStoreProductType) public enum ProductType : Swift.Int {
    case consumable
    case nonConsumable
    case nonRenewableSubscription
    case autoRenewableSubscription
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
extension RevenueCat.StoreProduct.ProductCategory : Swift.Sendable {
}
extension RevenueCat.StoreProduct.ProductType : Swift.Sendable {
}
extension RevenueCat.Purchases {
  @available(iOS, obsoleted: 1, renamed: "restorePurchases(completion:)")
  @available(tvOS, obsoleted: 1, renamed: "restorePurchases(completion:)")
  @available(watchOS, obsoleted: 1, renamed: "restorePurchases(completion:)")
  @available(macOS, obsoleted: 1, renamed: "restorePurchases(completion:)")
  @objc(restoreTransactionsWithCompletionBlock:) final public func restoreTransactions(completion: ((RevenueCat.CustomerInfo?, (any Swift.Error)?) -> Swift.Void)? = nil)
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS, unavailable, introduced: 13.0, renamed: "restorePurchases()")
  @available(tvOS, unavailable, introduced: 13.0, renamed: "restorePurchases()")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "restorePurchases()")
  @available(macOS, unavailable, introduced: 10.15, renamed: "restorePurchases()")
  @available(macCatalyst, unavailable, introduced: 13.0, renamed: "restorePurchases()")
  final public func restoreTransactions() async throws -> RevenueCat.CustomerInfo
  #endif
  @available(iOS, obsoleted: 1, renamed: "getCustomerInfo(completion:)")
  @available(tvOS, obsoleted: 1, renamed: "getCustomerInfo(completion:)")
  @available(watchOS, obsoleted: 1, renamed: "getCustomerInfo(completion:)")
  @available(macOS, obsoleted: 1, renamed: "getCustomerInfo(completion:)")
  @objc final public func customerInfo(completion: @escaping (RevenueCat.CustomerInfo?, (any Swift.Error)?) -> Swift.Void)
  @available(iOS, obsoleted: 1, renamed: "getCustomerInfo(completion:)")
  @available(tvOS, obsoleted: 1, renamed: "getCustomerInfo(completion:)")
  @available(watchOS, obsoleted: 1, renamed: "getCustomerInfo(completion:)")
  @available(macOS, obsoleted: 1, renamed: "getCustomerInfo(completion:)")
  @objc(purchaserInfoWithCompletionBlock:) final public func purchaserInfo(completion: @escaping (RevenueCat.CustomerInfo?, (any Swift.Error)?) -> Swift.Void)
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS, unavailable, introduced: 13.0, renamed: "customerInfo()")
  @available(tvOS, unavailable, introduced: 13.0, renamed: "customerInfo()")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "customerInfo()")
  @available(macOS, unavailable, introduced: 10.15, renamed: "customerInfo()")
  @available(macCatalyst, unavailable, introduced: 13.0, renamed: "customerInfo()")
  final public func purchaserInfo() async throws -> RevenueCat.CustomerInfo
  #endif
  @available(iOS, obsoleted: 1, renamed: "getProducts(_:completion:)")
  @available(tvOS, obsoleted: 1, renamed: "getProducts(_:completion:)")
  @available(watchOS, obsoleted: 1, renamed: "getProducts(_:completion:)")
  @available(macOS, obsoleted: 1, renamed: "getProducts(_:completion:)")
  @objc(productsWithIdentifiers:completionBlock:) final public func products(_ productIdentifiers: [Swift.String], completion: @escaping ([StoreKit.SKProduct]) -> Swift.Void)
  @available(iOS, obsoleted: 1, renamed: "getOfferings(completion:)")
  @available(tvOS, obsoleted: 1, renamed: "getOfferings(completion:)")
  @available(watchOS, obsoleted: 1, renamed: "getOfferings(completion:)")
  @available(macOS, obsoleted: 1, renamed: "getOfferings(completion:)")
  @objc(offeringsWithCompletionBlock:) final public func offerings(completion: @escaping (RevenueCat.Offerings?, (any Swift.Error)?) -> Swift.Void)
  #if compiler(>=5.3) && $Sendable
  @available(iOS, obsoleted: 1, renamed: "purchase(package:completion:)")
  @available(tvOS, obsoleted: 1, renamed: "purchase(package:completion:)")
  @available(watchOS, obsoleted: 1, renamed: "purchase(package:completion:)")
  @available(macOS, obsoleted: 1, renamed: "purchase(package:completion:)")
  @objc(purchasePackage:withCompletionBlock:) final public func purchasePackage(_ package: RevenueCat.Package, _ completion: @escaping RevenueCat.PurchaseCompletedBlock)
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS, unavailable, introduced: 13.0, renamed: "purchase(package:)")
  @available(tvOS, unavailable, introduced: 13.0, renamed: "purchase(package:)")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "purchase(package:)")
  @available(macOS, unavailable, introduced: 10.15, renamed: "purchase(package:)")
  @available(macCatalyst, unavailable, introduced: 13.0, renamed: "purchase(package:)")
  final public func purchasePackage(_ package: RevenueCat.Package) async throws -> RevenueCat.PurchaseResultData
  #endif
  #if compiler(>=5.3) && $Sendable
  @available(iOS, unavailable, introduced: 12.2, renamed: "purchase(package:promotionalOffer:completion:)")
  @available(tvOS, unavailable, introduced: 12.2, renamed: "purchase(package:promotionalOffer:completion:)")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "purchase(package:promotionalOffer:completion:)")
  @available(macOS, unavailable, introduced: 10.14.4, renamed: "purchase(package:promotionalOffer:completion:)")
  @available(macCatalyst, unavailable, introduced: 13.0, renamed: "purchase(package:promotionalOffer:completion:)")
  @objc(purchasePackage:withDiscount:completionBlock:) final public func purchasePackage(_ package: RevenueCat.Package, discount: StoreKit.SKPaymentDiscount, _ completion: @escaping RevenueCat.PurchaseCompletedBlock)
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS, unavailable, introduced: 13.0, renamed: "purchase(package:promotionalOffer:)")
  @available(tvOS, unavailable, introduced: 13.0, renamed: "purchase(package:promotionalOffer:)")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "purchase(package:promotionalOffer:)")
  @available(macOS, unavailable, introduced: 10.15, renamed: "purchase(package:promotionalOffer:)")
  @available(macCatalyst, unavailable, introduced: 13.0, renamed: "purchase(package:promotionalOffer:)")
  final public func purchasePackage(_ package: RevenueCat.Package, discount: StoreKit.SKPaymentDiscount) async throws -> RevenueCat.PurchaseResultData
  #endif
  #if compiler(>=5.3) && $Sendable
  @available(iOS, obsoleted: 1, renamed: "purchase(product:_:)")
  @available(tvOS, obsoleted: 1, renamed: "purchase(product:_:)")
  @available(watchOS, obsoleted: 1, renamed: "purchase(product:_:)")
  @available(macOS, obsoleted: 1, renamed: "purchase(product:_:)")
  @objc(purchaseProduct:withCompletionBlock:) final public func purchaseProduct(_ product: StoreKit.SKProduct, _ completion: @escaping RevenueCat.PurchaseCompletedBlock)
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS, unavailable, introduced: 13.0, renamed: "purchase(product:)")
  @available(tvOS, unavailable, introduced: 13.0, renamed: "purchase(product:)")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "purchase(product:)")
  @available(macOS, unavailable, introduced: 10.15, renamed: "purchase(product:)")
  @available(macCatalyst, unavailable, introduced: 13.0, renamed: "purchase(product:)")
  final public func purchaseProduct(_ product: StoreKit.SKProduct) async throws
  #endif
  #if compiler(>=5.3) && $Sendable
  @available(iOS, unavailable, introduced: 12.2, renamed: "purchase(product:promotionalOffer:completion:)")
  @available(tvOS, unavailable, introduced: 12.2, renamed: "purchase(product:promotionalOffer:completion:)")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "purchase(product:promotionalOffer:completion:)")
  @available(macOS, unavailable, introduced: 10.14.4, renamed: "purchase(product:promotionalOffer:completion:)")
  @available(macCatalyst, unavailable, introduced: 13.0, renamed: "purchase(product:promotionalOffer:completion:)")
  @objc(purchaseProduct:withDiscount:completionBlock:) final public func purchaseProduct(_ product: StoreKit.SKProduct, discount: StoreKit.SKPaymentDiscount, _ completion: @escaping RevenueCat.PurchaseCompletedBlock)
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS, unavailable, introduced: 13.0, renamed: "purchase(product:promotionalOffer:)")
  @available(tvOS, unavailable, introduced: 13.0, renamed: "purchase(product:promotionalOffer:)")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "purchase(product:promotionalOffer:)")
  @available(macOS, unavailable, introduced: 10.15, renamed: "purchase(product:promotionalOffer:)")
  @available(macCatalyst, unavailable, introduced: 13.0, renamed: "purchase(product:promotionalOffer:)")
  final public func purchaseProduct(_ product: StoreKit.SKProduct, discount: StoreKit.SKPaymentDiscount) async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS, unavailable, introduced: 13.0, renamed: "purchase(package:promotionalOffer:)")
  @available(tvOS, unavailable, introduced: 13.0, renamed: "purchase(package:promotionalOffer:)")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "purchase(package:promotionalOffer:)")
  @available(macOS, unavailable, introduced: 10.15, renamed: "purchase(package:promotionalOffer:)")
  @available(macCatalyst, unavailable, introduced: 13.0, renamed: "purchase(package:promotionalOffer:)")
  final public func purchase(package: RevenueCat.Package, discount: RevenueCat.StoreProductDiscount) async throws -> RevenueCat.PurchaseResultData
  #endif
  #if compiler(>=5.3) && $Sendable
  @available(iOS, unavailable, introduced: 12.2, renamed: "purchase(package:promotionalOffer:completion:)")
  @available(tvOS, unavailable, introduced: 12.2, renamed: "purchase(package:promotionalOffer:completion:)")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "purchase(package:promotionalOffer:completion:)")
  @available(macOS, unavailable, introduced: 10.14.4, renamed: "purchase(package:promotionalOffer:completion:)")
  @available(macCatalyst, unavailable, introduced: 12.2, renamed: "purchase(package:promotionalOffer:completion:)")
  final public func purchase(package: RevenueCat.Package, discount: RevenueCat.StoreProductDiscount, completion: @escaping RevenueCat.PurchaseCompletedBlock)
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS, unavailable, introduced: 13.0, renamed: "purchase(package:promotionalOffer:)")
  @available(tvOS, unavailable, introduced: 13.0, renamed: "purchase(package:promotionalOffer:)")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "purchase(package:promotionalOffer:)")
  @available(macOS, unavailable, introduced: 10.15, renamed: "purchase(package:promotionalOffer:)")
  @available(macCatalyst, unavailable, introduced: 13.0, renamed: "purchase(package:promotionalOffer:)")
  final public func purchase(product: RevenueCat.StoreProduct, discount: RevenueCat.StoreProductDiscount) async throws -> RevenueCat.PurchaseResultData
  #endif
  #if compiler(>=5.3) && $Sendable
  @available(iOS, unavailable, introduced: 12.2, renamed: "purchase(package:promotionalOffer:completion:)")
  @available(tvOS, unavailable, introduced: 12.2, renamed: "purchase(package:promotionalOffer:completion:)")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "purchase(package:promotionalOffer:completion:)")
  @available(macOS, unavailable, introduced: 10.14.4, renamed: "purchase(package:promotionalOffer:completion:)")
  @available(macCatalyst, unavailable, introduced: 12.2, renamed: "purchase(package:promotionalOffer:completion:)")
  final public func purchase(product: RevenueCat.StoreProduct, discount: RevenueCat.StoreProductDiscount, completion: @escaping RevenueCat.PurchaseCompletedBlock)
  #endif
  @available(iOS, unavailable, introduced: 13.0, renamed: "getPromotionalOffer(forProductDiscount:product:)")
  @available(tvOS, unavailable, introduced: 13.0, renamed: "getPromotionalOffer(forProductDiscount:product:)")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "getPromotionalOffer(forProductDiscount:product:)")
  @available(macOS, unavailable, introduced: 10.15, renamed: "getPromotionalOffer(forProductDiscount:product:)")
  @available(macCatalyst, unavailable, introduced: 13.0, renamed: "getPromotionalOffer(forProductDiscount:product:)")
  final public func checkPromotionalDiscountEligibility(forProductDiscount: RevenueCat.StoreProductDiscount, product: RevenueCat.StoreProduct)
  @available(iOS, unavailable, introduced: 12.2, renamed: "getPromotionalOffer(forProductDiscount:product:completion:)")
  @available(tvOS, unavailable, introduced: 12.2, renamed: "getPromotionalOffer(forProductDiscount:product:completion:)")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "getPromotionalOffer(forProductDiscount:product:completion:)")
  @available(macOS, unavailable, introduced: 10.14.4, renamed: "getPromotionalOffer(forProductDiscount:product:completion:)")
  @available(macCatalyst, unavailable, introduced: 12.2, renamed: "getPromotionalOffer(forProductDiscount:product:completion:)")
  final public func checkPromotionalDiscountEligibility(forProductDiscount: RevenueCat.StoreProductDiscount, product: RevenueCat.StoreProduct, completion: @escaping (Swift.AnyObject, (any Swift.Error)?) -> Swift.Void)
  @available(iOS, obsoleted: 1, renamed: "invalidateCustomerInfoCache")
  @available(tvOS, obsoleted: 1, renamed: "invalidateCustomerInfoCache")
  @available(watchOS, obsoleted: 1, renamed: "invalidateCustomerInfoCache")
  @available(macOS, obsoleted: 1, renamed: "invalidateCustomerInfoCache")
  @available(macCatalyst, obsoleted: 1, renamed: "invalidateCustomerInfoCache")
  @objc final public func invalidatePurchaserInfoCache()
  @available(iOS, obsoleted: 1, renamed: "checkTrialOrIntroDiscountEligibility(_:completion:)")
  @available(tvOS, obsoleted: 1, renamed: "checkTrialOrIntroDiscountEligibility(_:completion:)")
  @available(watchOS, obsoleted: 1, renamed: "checkTrialOrIntroDiscountEligibility(_:completion:)")
  @available(macOS, obsoleted: 1, renamed: "checkTrialOrIntroDiscountEligibility(_:completion:)")
  @available(macCatalyst, obsoleted: 1, renamed: "checkTrialOrIntroDiscountEligibility(_:completion:)")
  @objc(checkTrialOrIntroductoryPriceEligibility:completion:) final public func checkTrialOrIntroductoryPriceEligibility(_ productIdentifiers: [Swift.String], completion: @escaping ([Swift.String : RevenueCat.IntroEligibility]) -> Swift.Void)
  @available(iOS, unavailable, introduced: 12.2, message: "Check eligibility for a discount using getPromotionalOffer:")
  @available(tvOS, unavailable, introduced: 12.2, message: "Check eligibility for a discount using getPromotionalOffer:")
  @available(watchOS, unavailable, introduced: 6.2, message: "Check eligibility for a discount using getPromotionalOffer:")
  @available(macOS, unavailable, introduced: 10.14.4, message: "Check eligibility for a discount using getPromotionalOffer:")
  @available(macCatalyst, unavailable, introduced: 13.0, message: "Check eligibility for a discount using getPromotionalOffer:")
  @objc(paymentDiscountForProductDiscount:product:completion:) final public func paymentDiscount(for discount: StoreKit.SKProductDiscount, product: StoreKit.SKProduct, completion: @escaping (StoreKit.SKPaymentDiscount?, (any Swift.Error)?) -> Swift.Void)
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS, unavailable, introduced: 13.0, message: "Check eligibility for a discount using getPromotionalOffer:")
  @available(tvOS, unavailable, introduced: 13.0, message: "Check eligibility for a discount using getPromotionalOffer:")
  @available(watchOS, unavailable, introduced: 6.2, message: "Check eligibility for a discount using getPromotionalOffer:")
  @available(macOS, unavailable, introduced: 10.15, message: "Check eligibility for a discount using getPromotionalOffer:")
  @available(macCatalyst, unavailable, introduced: 13.0, message: "Check eligibility for a discount using getPromotionalOffer:")
  final public func paymentDiscount(for discount: StoreKit.SKProductDiscount, product: StoreKit.SKProduct) async throws -> StoreKit.SKPaymentDiscount
  #endif
  @available(iOS, obsoleted: 1, message: "This was never meant to be public. Use `PurchasesDelegate.purchases(_:readyForPromotedProduct:purchase:)`")
  @available(tvOS, obsoleted: 1, message: "This was never meant to be public. Use `PurchasesDelegate.purchases(_:readyForPromotedProduct:purchase:)`")
  @available(watchOS, obsoleted: 1, message: "This was never meant to be public. Use `PurchasesDelegate.purchases(_:readyForPromotedProduct:purchase:)`")
  @available(macOS, obsoleted: 1, message: "This was never meant to be public. Use `PurchasesDelegate.purchases(_:readyForPromotedProduct:purchase:)`")
  @available(macCatalyst, obsoleted: 1, message: "This was never meant to be public. Use `PurchasesDelegate.purchases(_:readyForPromotedProduct:purchase:)`")
  @objc final public func shouldPurchasePromoProduct(_ product: RevenueCat.StoreProduct, defermentBlock: @escaping RevenueCat.StartPurchaseBlock)
  @available(iOS, obsoleted: 1, renamed: "logIn")
  @available(tvOS, obsoleted: 1, renamed: "logIn")
  @available(watchOS, obsoleted: 1, renamed: "logIn")
  @available(macOS, obsoleted: 1, renamed: "logIn")
  @objc(createAlias:completionBlock:) final public func createAlias(_ alias: Swift.String, _ completion: ((RevenueCat.CustomerInfo?, (any Swift.Error)?) -> Swift.Void)?)
  @available(iOS, obsoleted: 1, renamed: "logIn")
  @available(tvOS, obsoleted: 1, renamed: "logIn")
  @available(watchOS, obsoleted: 1, renamed: "logIn")
  @available(macOS, obsoleted: 1, renamed: "logIn")
  @objc(identify:completionBlock:) final public func identify(_ appUserID: Swift.String, _ completion: ((RevenueCat.CustomerInfo?, (any Swift.Error)?) -> Swift.Void)?)
  @available(iOS, obsoleted: 1, renamed: "logOut")
  @available(tvOS, obsoleted: 1, renamed: "logOut")
  @available(watchOS, obsoleted: 1, renamed: "logOut")
  @available(macOS, obsoleted: 1, renamed: "logOut")
  @objc(resetWithCompletionBlock:) final public func reset(completion: ((RevenueCat.CustomerInfo?, (any Swift.Error)?) -> Swift.Void)?)
}
@available(iOS, obsoleted: 1, renamed: "StartPurchaseBlock")
@available(tvOS, obsoleted: 1, renamed: "StartPurchaseBlock")
@available(watchOS, obsoleted: 1, renamed: "StartPurchaseBlock")
@available(macOS, obsoleted: 1, renamed: "StartPurchaseBlock")
public typealias DeferredPromotionalPurchaseBlock = RevenueCat.StartPurchaseBlock
@_inheritsConvenienceInitializers @available(iOS, obsoleted: 1, renamed: "CustomerInfo")
@available(tvOS, obsoleted: 1, renamed: "CustomerInfo")
@available(watchOS, obsoleted: 1, renamed: "CustomerInfo")
@available(macOS, obsoleted: 1, renamed: "CustomerInfo")
@objc(RCPurchaserInfo) public class PurchaserInfo : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @available(iOS, obsoleted: 1, renamed: "StoreTransaction")
@available(tvOS, obsoleted: 1, renamed: "StoreTransaction")
@available(watchOS, obsoleted: 1, renamed: "StoreTransaction")
@available(macOS, obsoleted: 1, renamed: "StoreTransaction")
@objc(RCTransaction) public class Transaction : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc deinit
}
extension RevenueCat.StoreTransaction {
  @available(iOS, obsoleted: 1, renamed: "productIdentifier")
  @available(tvOS, obsoleted: 1, renamed: "productIdentifier")
  @available(watchOS, obsoleted: 1, renamed: "productIdentifier")
  @available(macOS, obsoleted: 1, renamed: "productIdentifier")
  @objc final public var productId: Swift.String {
    @objc get
  }
  @available(iOS, obsoleted: 1, renamed: "transactionIdentifier")
  @available(tvOS, obsoleted: 1, renamed: "transactionIdentifier")
  @available(watchOS, obsoleted: 1, renamed: "transactionIdentifier")
  @available(macOS, obsoleted: 1, renamed: "transactionIdentifier")
  @objc final public var revenueCatId: Swift.String {
    @objc get
  }
}
extension RevenueCat.Package {
  @available(iOS, obsoleted: 1, renamed: "storeProduct", message: "Use StoreProduct instead")
  @available(tvOS, obsoleted: 1, renamed: "storeProduct", message: "Use StoreProduct instead")
  @available(watchOS, obsoleted: 1, renamed: "storeProduct", message: "Use StoreProduct instead")
  @available(macOS, obsoleted: 1, renamed: "storeProduct", message: "Use StoreProduct instead")
  @available(macCatalyst, obsoleted: 1, renamed: "storeProduct", message: "Use StoreProduct instead")
  @objc final public var product: StoreKit.SKProduct {
    @objc get
  }
}
extension RevenueCat.StoreProductDiscount.PaymentMode {
  @available(iOS, obsoleted: 1, message: "This option no longer exists. PaymentMode would be nil instead.")
  @available(tvOS, obsoleted: 1, message: "This option no longer exists. PaymentMode would be nil instead.")
  @available(watchOS, obsoleted: 1, message: "This option no longer exists. PaymentMode would be nil instead.")
  @available(macOS, obsoleted: 1, message: "This option no longer exists. PaymentMode would be nil instead.")
  @available(macCatalyst, obsoleted: 1, message: "This option no longer exists. PaymentMode would be nil instead.")
  public static var none: RevenueCat.StoreProductDiscount.PaymentMode {
    get
  }
}
@available(iOS, obsoleted: 1, renamed: "StoreProductDiscount.PaymentMode")
@available(tvOS, obsoleted: 1, renamed: "StoreProductDiscount.PaymentMode")
@available(watchOS, obsoleted: 1, renamed: "StoreProductDiscount.PaymentMode")
@available(macOS, obsoleted: 1, renamed: "StoreProductDiscount.PaymentMode")
@available(macCatalyst, obsoleted: 1, renamed: "StoreProductDiscount.PaymentMode")
public enum RCPaymentMode {
}
@_inheritsConvenienceInitializers @available(iOS, obsoleted: 1, message: "Use PromotionalOffer instead")
@available(tvOS, obsoleted: 1, message: "Use PromotionalOffer instead")
@available(watchOS, obsoleted: 1, message: "Use PromotionalOffer instead")
@available(macOS, obsoleted: 1, message: "Use PromotionalOffer instead")
@available(macCatalyst, obsoleted: 1, message: "Use PromotionalOffer instead")
@objc(RCPromotionalOfferEligibility) public class PromotionalOfferEligibility : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc deinit
}
@available(iOS, obsoleted: 1, message: "Use ErrorCode instead")
@available(tvOS, obsoleted: 1, message: "Use ErrorCode instead")
@available(watchOS, obsoleted: 1, message: "Use ErrorCode instead")
@available(macOS, obsoleted: 1, message: "Use ErrorCode instead")
@available(macCatalyst, obsoleted: 1, message: "Use ErrorCode instead")
public var ErrorDomain: Foundation.NSErrorDomain {
  get
}
@available(iOS, obsoleted: 1, message: "Use ErrorCode instead")
@available(tvOS, obsoleted: 1, message: "Use ErrorCode instead")
@available(watchOS, obsoleted: 1, message: "Use ErrorCode instead")
@available(macOS, obsoleted: 1, message: "Use ErrorCode instead")
@available(macCatalyst, obsoleted: 1, message: "Use ErrorCode instead")
public enum RCBackendErrorCode {
}
@objc @_inheritsConvenienceInitializers @available(iOS, obsoleted: 1)
@available(tvOS, obsoleted: 1)
@available(watchOS, obsoleted: 1)
@available(macOS, obsoleted: 1)
@available(macCatalyst, obsoleted: 1)
public class RCPurchasesErrorUtils : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc deinit
}
extension RevenueCat.Purchases {
  @available(iOS, obsoleted: 1, renamed: "ErrorCode")
  @available(tvOS, obsoleted: 1, renamed: "ErrorCode")
  @available(watchOS, obsoleted: 1, renamed: "ErrorCode")
  @available(macOS, obsoleted: 1, renamed: "ErrorCode")
  @available(macCatalyst, obsoleted: 1, renamed: "ErrorCode")
  public enum Errors {
  }
  @available(iOS, obsoleted: 1)
  @available(tvOS, obsoleted: 1)
  @available(watchOS, obsoleted: 1)
  @available(macOS, obsoleted: 1)
  @available(macCatalyst, obsoleted: 1)
  public enum FinishableKey {
  }
  @available(iOS, obsoleted: 1)
  @available(tvOS, obsoleted: 1)
  @available(watchOS, obsoleted: 1)
  @available(macOS, obsoleted: 1)
  @available(macCatalyst, obsoleted: 1)
  public enum ReadableErrorCodeKey {
  }
  @available(iOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(tvOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(watchOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(macOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(macCatalyst, obsoleted: 1, message: "Remove `Purchases.`")
  public enum ErrorCode {
  }
  @available(iOS, obsoleted: 1)
  @available(tvOS, obsoleted: 1)
  @available(watchOS, obsoleted: 1)
  @available(macOS, obsoleted: 1)
  @available(macCatalyst, obsoleted: 1)
  public enum RevenueCatBackendErrorCode {
  }
  @available(iOS, obsoleted: 1, renamed: "StoreTransaction")
  @available(tvOS, obsoleted: 1, renamed: "StoreTransaction")
  @available(watchOS, obsoleted: 1, renamed: "StoreTransaction")
  @available(macOS, obsoleted: 1, renamed: "StoreTransaction")
  @available(macCatalyst, obsoleted: 1, renamed: "StoreTransaction")
  public enum Transaction {
  }
  @available(iOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(tvOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(watchOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(macOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(macCatalyst, obsoleted: 1, message: "Remove `Purchases.`")
  public enum EntitlementInfo {
  }
  @available(iOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(tvOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(watchOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(macOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(macCatalyst, obsoleted: 1, message: "Remove `Purchases.`")
  public enum EntitlementInfos {
  }
  @available(iOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(tvOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(watchOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(macOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(macCatalyst, obsoleted: 1, message: "Remove `Purchases.`")
  public enum PackageType {
  }
  @available(iOS, obsoleted: 1, renamed: "CustomerInfo")
  @available(tvOS, obsoleted: 1, renamed: "CustomerInfo")
  @available(watchOS, obsoleted: 1, renamed: "CustomerInfo")
  @available(macOS, obsoleted: 1, renamed: "CustomerInfo")
  @available(macCatalyst, obsoleted: 1, renamed: "CustomerInfo")
  public enum PurchaserInfo {
  }
  @available(iOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(tvOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(watchOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(macOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(macCatalyst, obsoleted: 1, message: "Remove `Purchases.`")
  public enum Offering {
  }
  @available(iOS, obsoleted: 1)
  @available(tvOS, obsoleted: 1)
  @available(watchOS, obsoleted: 1)
  @available(macOS, obsoleted: 1)
  @available(macCatalyst, obsoleted: 1)
  public enum ErrorUtils {
  }
  @available(iOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(tvOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(watchOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(macOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(macCatalyst, obsoleted: 1, message: "Remove `Purchases.`")
  public enum Store {
  }
  @available(iOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(tvOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(watchOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(macOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(macCatalyst, obsoleted: 1, message: "Remove `Purchases.`")
  public enum PeriodType {
  }
}
@_hasMissingDesignatedInitializers @objc(RCPromotionalOffer) final public class PromotionalOffer : ObjectiveC.NSObject {
  @objc final public let discount: RevenueCat.StoreProductDiscount
  @objc final public let signedData: RevenueCat.PromotionalOffer.SignedData
  @objc deinit
}
extension RevenueCat.PromotionalOffer : Swift.Sendable {
}
@objc extension RevenueCat.PromotionalOffer {
  @_hasMissingDesignatedInitializers @objc(RCPromotionalOfferSignedData) final public class SignedData : ObjectiveC.NSObject {
    @objc final public let identifier: Swift.String
    @objc final public let keyIdentifier: Swift.String
    @objc final public let nonce: Foundation.UUID
    @objc final public let signature: Swift.String
    @objc final public let timestamp: Swift.Int
    @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
    public static func == (lhs: RevenueCat.PromotionalOffer.SignedData, rhs: RevenueCat.PromotionalOffer.SignedData) -> Swift.Bool
    @objc deinit
  }
}
extension RevenueCat.PromotionalOffer.SignedData : Swift.Sendable {
}
public struct PaywallData {
  public var templateName: Swift.String
  public var config: RevenueCat.PaywallData.Configuration
  public var assetBaseURL: Foundation.URL
  public var revision: Swift.Int {
    get
    set
  }
}
public protocol PaywallLocalizedConfiguration {
  var title: Swift.String { get }
  var subtitle: Swift.String? { get }
  var callToAction: Swift.String { get }
  var callToActionWithIntroOffer: Swift.String? { get }
  var offerDetails: Swift.String? { get }
  var offerDetailsWithIntroOffer: Swift.String? { get }
  var offerName: Swift.String? { get }
  var features: [RevenueCat.PaywallData.LocalizedConfiguration.Feature] { get }
}
extension RevenueCat.PaywallData {
  public struct LocalizedConfiguration : RevenueCat.PaywallLocalizedConfiguration {
    public var title: Swift.String
    public var callToAction: Swift.String
    public var subtitle: Swift.String? {
      get
      set
    }
    public var callToActionWithIntroOffer: Swift.String? {
      get
      set
    }
    public var offerDetails: Swift.String? {
      get
      set
    }
    public var offerDetailsWithIntroOffer: Swift.String? {
      get
      set
    }
    public var offerName: Swift.String? {
      get
      set
    }
    public var features: [RevenueCat.PaywallData.LocalizedConfiguration.Feature] {
      get
      set
    }
    public init(title: Swift.String, subtitle: Swift.String? = nil, callToAction: Swift.String, callToActionWithIntroOffer: Swift.String? = nil, offerDetails: Swift.String?, offerDetailsWithIntroOffer: Swift.String? = nil, offerName: Swift.String? = nil, features: [RevenueCat.PaywallData.LocalizedConfiguration.Feature] = [])
  }
  public func config(for requiredLocale: Foundation.Locale) -> RevenueCat.PaywallData.LocalizedConfiguration?
}
extension RevenueCat.PaywallData.LocalizedConfiguration {
  public struct Feature {
    public var title: Swift.String
    public var content: Swift.String?
    public var iconID: Swift.String?
    public init(title: Swift.String, content: Swift.String? = nil, iconID: Swift.String? = nil)
  }
}
extension RevenueCat.PaywallData {
  public struct Configuration {
    public var packages: [Swift.String]
    public var defaultPackage: Swift.String?
    public var images: RevenueCat.PaywallData.Configuration.Images
    public var blurredBackgroundImage: Swift.Bool {
      get
      set
    }
    public var displayRestorePurchases: Swift.Bool {
      get
      set
    }
    public var termsOfServiceURL: Foundation.URL? {
      get
      set
    }
    public var privacyURL: Foundation.URL? {
      get
      set
    }
    public var colors: RevenueCat.PaywallData.Configuration.ColorInformation
    public init(packages: [Swift.String], defaultPackage: Swift.String? = nil, images: RevenueCat.PaywallData.Configuration.Images, colors: RevenueCat.PaywallData.Configuration.ColorInformation, blurredBackgroundImage: Swift.Bool = false, displayRestorePurchases: Swift.Bool = true, termsOfServiceURL: Foundation.URL? = nil, privacyURL: Foundation.URL? = nil)
  }
}
extension RevenueCat.PaywallData.Configuration {
  public struct Images {
    public var header: Swift.String? {
      get
      set
    }
    public var background: Swift.String? {
      get
      set
    }
    public var icon: Swift.String? {
      get
      set
    }
    public init(header: Swift.String? = nil, background: Swift.String? = nil, icon: Swift.String? = nil)
  }
}
extension RevenueCat.PaywallData.Configuration {
  public struct ColorInformation {
    public var light: RevenueCat.PaywallData.Configuration.Colors
    public var dark: RevenueCat.PaywallData.Configuration.Colors?
    public init(light: RevenueCat.PaywallData.Configuration.Colors, dark: RevenueCat.PaywallData.Configuration.Colors? = nil)
  }
  public struct Colors {
    public var background: RevenueCat.PaywallColor
    public var text1: RevenueCat.PaywallColor
    public var text2: RevenueCat.PaywallColor?
    public var text3: RevenueCat.PaywallColor?
    public var callToActionBackground: RevenueCat.PaywallColor
    public var callToActionForeground: RevenueCat.PaywallColor
    public var callToActionSecondaryBackground: RevenueCat.PaywallColor?
    public var accent1: RevenueCat.PaywallColor?
    public var accent2: RevenueCat.PaywallColor?
    public var accent3: RevenueCat.PaywallColor?
    public init(background: RevenueCat.PaywallColor, text1: RevenueCat.PaywallColor, text2: RevenueCat.PaywallColor? = nil, text3: RevenueCat.PaywallColor? = nil, callToActionBackground: RevenueCat.PaywallColor, callToActionForeground: RevenueCat.PaywallColor, callToActionSecondaryBackground: RevenueCat.PaywallColor? = nil, accent1: RevenueCat.PaywallColor? = nil, accent2: RevenueCat.PaywallColor? = nil, accent3: RevenueCat.PaywallColor? = nil)
  }
}
extension RevenueCat.PaywallData {
  public init(templateName: Swift.String, config: RevenueCat.PaywallData.Configuration, localization: RevenueCat.PaywallData.LocalizedConfiguration, assetBaseURL: Foundation.URL, revision: Swift.Int = 0)
}
extension RevenueCat.PaywallData.LocalizedConfiguration.Feature : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.PaywallData.LocalizedConfiguration : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.PaywallData.Configuration.ColorInformation : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.PaywallData.Configuration.Colors : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.PaywallData.Configuration.Images : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.PaywallData.Configuration : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.PaywallData : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.PaywallData.LocalizedConfiguration.Feature : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: RevenueCat.PaywallData.LocalizedConfiguration.Feature, b: RevenueCat.PaywallData.LocalizedConfiguration.Feature) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension RevenueCat.PaywallData.LocalizedConfiguration : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: RevenueCat.PaywallData.LocalizedConfiguration, b: RevenueCat.PaywallData.LocalizedConfiguration) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension RevenueCat.PaywallData.Configuration.ColorInformation : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: RevenueCat.PaywallData.Configuration.ColorInformation, b: RevenueCat.PaywallData.Configuration.ColorInformation) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension RevenueCat.PaywallData.Configuration.Colors : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: RevenueCat.PaywallData.Configuration.Colors, b: RevenueCat.PaywallData.Configuration.Colors) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension RevenueCat.PaywallData.Configuration.Images : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: RevenueCat.PaywallData.Configuration.Images, b: RevenueCat.PaywallData.Configuration.Images) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension RevenueCat.PaywallData.Configuration : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: RevenueCat.PaywallData.Configuration, b: RevenueCat.PaywallData.Configuration) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension RevenueCat.PaywallData : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: RevenueCat.PaywallData, b: RevenueCat.PaywallData) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension RevenueCat.PaywallData.LocalizedConfiguration.Feature : Swift.Sendable {
}
extension RevenueCat.PaywallData.LocalizedConfiguration : Swift.Sendable {
}
extension RevenueCat.PaywallData.Configuration.ColorInformation : Swift.Sendable {
}
extension RevenueCat.PaywallData.Configuration.Colors : Swift.Sendable {
}
extension RevenueCat.PaywallData.Configuration.Images : Swift.Sendable {
}
extension RevenueCat.PaywallData.Configuration : Swift.Sendable {
}
extension RevenueCat.PaywallData : Swift.Sendable {
}
@_hasMissingDesignatedInitializers @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
@objc(RCPurchasesDiagnostics) final public class PurchasesDiagnostics : ObjectiveC.NSObject {
  @objc public static let `default`: RevenueCat.PurchasesDiagnostics
  @objc deinit
}
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
extension RevenueCat.PurchasesDiagnostics {
  public enum Error : Swift.Error {
    case failedConnectingToAPI(any Swift.Error)
    case invalidAPIKey
    case failedFetchingOfferings(any Swift.Error)
    case failedMakingSignedRequest(any Swift.Error)
    case unknown(any Swift.Error)
  }
}
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
extension RevenueCat.PurchasesDiagnostics {
  #if compiler(>=5.3) && $AsyncAwait
  @objc(testSDKHealthWithCompletion:) final public func testSDKHealth() async throws
  #endif
}
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
extension RevenueCat.PurchasesDiagnostics.Error : Foundation.CustomNSError {
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
}
@_hasMissingDesignatedInitializers @objc(RCNonSubscriptionTransaction) final public class NonSubscriptionTransaction : ObjectiveC.NSObject {
  @objc final public let productIdentifier: Swift.String
  @objc final public let purchaseDate: Foundation.Date
  @objc final public let transactionIdentifier: Swift.String
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc deinit
}
extension RevenueCat.NonSubscriptionTransaction : Swift.Sendable {
}
extension RevenueCat.Purchases {
  @available(iOS, deprecated: 1, renamed: "checkTrialOrIntroDiscountEligibility(productIdentifiers:)")
  @available(tvOS, deprecated: 1, renamed: "checkTrialOrIntroDiscountEligibility(productIdentifiers:)")
  @available(watchOS, deprecated: 1, renamed: "checkTrialOrIntroDiscountEligibility(productIdentifiers:)")
  @available(macOS, deprecated: 1, renamed: "checkTrialOrIntroDiscountEligibility(productIdentifiers:)")
  @available(macCatalyst, deprecated: 1, renamed: "checkTrialOrIntroDiscountEligibility(productIdentifiers:)")
  final public func checkTrialOrIntroDiscountEligibility(_ productIdentifiers: [Swift.String], completion: @escaping ([Swift.String : RevenueCat.IntroEligibility]) -> Swift.Void)
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS, introduced: 13.0, deprecated: 1, renamed: "checkTrialOrIntroDiscountEligibility(productIdentifiers:)")
  @available(tvOS, introduced: 13.0, deprecated: 1, renamed: "checkTrialOrIntroDiscountEligibility(productIdentifiers:)")
  @available(watchOS, introduced: 6.2, deprecated: 1, renamed: "checkTrialOrIntroDiscountEligibility(productIdentifiers:)")
  @available(macOS, introduced: 10.15, deprecated: 1, renamed: "checkTrialOrIntroDiscountEligibility(productIdentifiers:)")
  @available(macCatalyst, introduced: 13.0, deprecated: 1, renamed: "checkTrialOrIntroDiscountEligibility(productIdentifiers:)")
  final public func checkTrialOrIntroDiscountEligibility(_ productIdentifiers: [Swift.String]) async -> [Swift.String : RevenueCat.IntroEligibility]
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS, deprecated, introduced: 13.0, renamed: "promotionalOffer(forProductDiscount:product:)")
  @available(tvOS, deprecated, introduced: 13.0, renamed: "promotionalOffer(forProductDiscount:product:)")
  @available(watchOS, deprecated, introduced: 6.2, renamed: "promotionalOffer(forProductDiscount:product:)")
  @available(macOS, deprecated, introduced: 10.15, renamed: "promotionalOffer(forProductDiscount:product:)")
  @available(macCatalyst, deprecated, introduced: 13.0, renamed: "promotionalOffer(forProductDiscount:product:)")
  final public func getPromotionalOffer(forProductDiscount discount: RevenueCat.StoreProductDiscount, product: RevenueCat.StoreProduct) async throws -> RevenueCat.PromotionalOffer
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS, deprecated, introduced: 13.0, renamed: "eligiblePromotionalOffers(forProduct:)")
  @available(tvOS, deprecated, introduced: 13.0, renamed: "eligiblePromotionalOffers(forProduct:)")
  @available(watchOS, deprecated, introduced: 6.2, renamed: "eligiblePromotionalOffers(forProduct:)")
  @available(macOS, deprecated, introduced: 10.15, renamed: "eligiblePromotionalOffers(forProduct:)")
  @available(macCatalyst, deprecated, introduced: 13.0, renamed: "eligiblePromotionalOffers(forProduct:)")
  final public func getEligiblePromotionalOffers(forProduct product: RevenueCat.StoreProduct) async -> [RevenueCat.PromotionalOffer]
  #endif
  @available(iOS, deprecated: 1, renamed: "configure(with:)")
  @available(tvOS, deprecated: 1, renamed: "configure(with:)")
  @available(watchOS, deprecated: 1, renamed: "configure(with:)")
  @available(macOS, deprecated: 1, renamed: "configure(with:)")
  @available(macCatalyst, deprecated: 1, renamed: "configure(with:)")
  @discardableResult
  @objc(configureWithAPIKey:appUserID:observerMode:userDefaults:) public static func configure(withAPIKey apiKey: Swift.String, appUserID: Swift.String?, observerMode: Swift.Bool, userDefaults: Foundation.UserDefaults?) -> RevenueCat.Purchases
  @available(iOS, deprecated: 1, renamed: "configure(with:)")
  @available(tvOS, deprecated: 1, renamed: "configure(with:)")
  @available(watchOS, deprecated: 1, renamed: "configure(with:)")
  @available(macOS, deprecated: 1, renamed: "configure(with:)")
  @available(macCatalyst, deprecated: 1, renamed: "configure(with:)")
  @discardableResult
  @objc(configureWithAPIKey:appUserID:observerMode:userDefaults:useStoreKit2IfAvailable:) public static func configure(withAPIKey apiKey: Swift.String, appUserID: Swift.String?, observerMode: Swift.Bool, userDefaults: Foundation.UserDefaults?, useStoreKit2IfAvailable: Swift.Bool) -> RevenueCat.Purchases
  @available(iOS, deprecated: 1, renamed: "configure(with:)")
  @available(tvOS, deprecated: 1, renamed: "configure(with:)")
  @available(watchOS, deprecated: 1, renamed: "configure(with:)")
  @available(macOS, deprecated: 1, renamed: "configure(with:)")
  @available(macCatalyst, deprecated: 1, renamed: "configure(with:)")
  @discardableResult
  @objc(configureWithAPIKey:appUserID:observerMode:userDefaults:useStoreKit2IfAvailable:dangerousSettings:) public static func configure(withAPIKey apiKey: Swift.String, appUserID: Swift.String?, observerMode: Swift.Bool, userDefaults: Foundation.UserDefaults?, useStoreKit2IfAvailable: Swift.Bool, dangerousSettings: RevenueCat.DangerousSettings?) -> RevenueCat.Purchases
  @available(*, deprecated, message: "Use Purchases.shared.attribution.enableAdServicesAttributionTokenCollection() instead")
  @objc public static var automaticAppleSearchAdsAttributionCollection: Swift.Bool
}
extension RevenueCat.Purchases {
  @available(iOS, deprecated, renamed: "attribution.collectDeviceIdentifiers()")
  @available(tvOS, deprecated, renamed: "attribution.collectDeviceIdentifiers()")
  @available(watchOS, deprecated, renamed: "attribution.collectDeviceIdentifiers()")
  @available(macOS, deprecated, renamed: "attribution.collectDeviceIdentifiers()")
  @available(macCatalyst, deprecated, renamed: "attribution.collectDeviceIdentifiers()")
  @objc final public func collectDeviceIdentifiers()
  @available(iOS, deprecated, renamed: "attribution.setAttributes(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setAttributes(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setAttributes(_:)")
  @available(macOS, deprecated, renamed: "attribution.setAttributes(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setAttributes(_:)")
  @objc final public func setAttributes(_ attributes: [Swift.String : Swift.String])
  @available(iOS, deprecated, renamed: "attribution.setEmail(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setEmail(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setEmail(_:)")
  @available(macOS, deprecated, renamed: "attribution.setEmail(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setEmail(_:)")
  @objc final public func setEmail(_ email: Swift.String?)
  @available(iOS, deprecated, renamed: "attribution.setPhoneNumber(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setPhoneNumber(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setPhoneNumber(_:)")
  @available(macOS, deprecated, renamed: "attribution.setPhoneNumber(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setPhoneNumber(_:)")
  @objc final public func setPhoneNumber(_ phoneNumber: Swift.String?)
  @available(iOS, deprecated, renamed: "attribution.setDisplayName(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setDisplayName(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setDisplayName(_:)")
  @available(macOS, deprecated, renamed: "attribution.setDisplayName(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setDisplayName(_:)")
  @objc final public func setDisplayName(_ displayName: Swift.String?)
  @available(iOS, deprecated, renamed: "attribution.setPushToken(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setPushToken(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setPushToken(_:)")
  @available(macOS, deprecated, renamed: "attribution.setPushToken(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setPushToken(_:)")
  @objc final public func setPushToken(_ pushToken: Foundation.Data?)
  @available(iOS, deprecated, renamed: "attribution.setPushTokenString(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setPushTokenString(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setPushTokenString(_:)")
  @available(macOS, deprecated, renamed: "attribution.setPushTokenString(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setPushTokenString(_:)")
  @objc final public func setPushTokenString(_ pushToken: Swift.String?)
  @available(iOS, deprecated, renamed: "attribution.setAdjustID(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setAdjustID(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setAdjustID(_:)")
  @available(macOS, deprecated, renamed: "attribution.setAdjustID(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setAdjustID(_:)")
  @objc final public func setAdjustID(_ adjustID: Swift.String?)
  @available(iOS, deprecated, renamed: "attribution.setAppsflyerID(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setAppsflyerID(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setAppsflyerID(_:)")
  @available(macOS, deprecated, renamed: "attribution.setAppsflyerID(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setAppsflyerID(_:)")
  @objc final public func setAppsflyerID(_ appsflyerID: Swift.String?)
  @available(iOS, deprecated, renamed: "attribution.setFBAnonymousID(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setFBAnonymousID(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setFBAnonymousID(_:)")
  @available(macOS, deprecated, renamed: "attribution.setFBAnonymousID(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setFBAnonymousID(_:)")
  @objc final public func setFBAnonymousID(_ fbAnonymousID: Swift.String?)
  @available(iOS, deprecated, renamed: "attribution.setMparticleID(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setMparticleID(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setMparticleID(_:)")
  @available(macOS, deprecated, renamed: "attribution.setMparticleID(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setMparticleID(_:)")
  @objc final public func setMparticleID(_ mparticleID: Swift.String?)
  @available(iOS, deprecated, renamed: "attribution.setOnesignalID(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setOnesignalID(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setOnesignalID(_:)")
  @available(macOS, deprecated, renamed: "attribution.setOnesignalID(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setOnesignalID(_:)")
  @objc final public func setOnesignalID(_ onesignalID: Swift.String?)
  @available(iOS, deprecated, renamed: "attribution.setAirshipChannelID(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setAirshipChannelID(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setAirshipChannelID(_:)")
  @available(macOS, deprecated, renamed: "attribution.setAirshipChannelID(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setAirshipChannelID(_:)")
  @objc final public func setAirshipChannelID(_ airshipChannelID: Swift.String?)
  @available(iOS, deprecated, renamed: "attribution.setCleverTapID(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setCleverTapID(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setCleverTapID(_:)")
  @available(macOS, deprecated, renamed: "attribution.setCleverTapID(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setCleverTapID(_:)")
  @objc final public func setCleverTapID(_ cleverTapID: Swift.String?)
  @available(iOS, deprecated, renamed: "attribution.setMixpanelDistinctID(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setMixpanelDistinctID(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setMixpanelDistinctID(_:)")
  @available(macOS, deprecated, renamed: "attribution.setMixpanelDistinctID(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setMixpanelDistinctID(_:)")
  @objc final public func setMixpanelDistinctID(_ mixpanelDistinctID: Swift.String?)
  @available(iOS, deprecated, renamed: "attribution.setFirebaseAppInstanceID(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setFirebaseAppInstanceID(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setFirebaseAppInstanceID(_:)")
  @available(macOS, deprecated, renamed: "attribution.setFirebaseAppInstanceID(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setFirebaseAppInstanceID(_:)")
  @objc final public func setFirebaseAppInstanceID(_ firebaseAppInstanceID: Swift.String?)
  @available(iOS, deprecated, renamed: "attribution.setMediaSource(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setMediaSource(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setMediaSource(_:)")
  @available(macOS, deprecated, renamed: "attribution.setMediaSource(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setMediaSource(_:)")
  @objc final public func setMediaSource(_ mediaSource: Swift.String?)
  @available(iOS, deprecated, renamed: "attribution.setCampaign(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setCampaign(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setCampaign(_:)")
  @available(macOS, deprecated, renamed: "attribution.setCampaign(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setCampaign(_:)")
  @objc final public func setCampaign(_ campaign: Swift.String?)
  @available(iOS, deprecated, renamed: "attribution.setAdGroup(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setAdGroup(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setAdGroup(_:)")
  @available(macOS, deprecated, renamed: "attribution.setAdGroup(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setAdGroup(_:)")
  @objc final public func setAdGroup(_ adGroup: Swift.String?)
  @available(iOS, deprecated, renamed: "attribution.setAd(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setAd(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setAd(_:)")
  @available(macOS, deprecated, renamed: "attribution.setAd(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setAd(_:)")
  @objc final public func setAd(_ installAd: Swift.String?)
  @available(iOS, deprecated, renamed: "attribution.setKeyword(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setKeyword(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setKeyword(_:)")
  @available(macOS, deprecated, renamed: "attribution.setKeyword(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setKeyword(_:)")
  @objc final public func setKeyword(_ keyword: Swift.String?)
  @available(iOS, deprecated, renamed: "attribution.setCreative(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setCreative(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setCreative(_:)")
  @available(macOS, deprecated, renamed: "attribution.setCreative(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setCreative(_:)")
  @objc final public func setCreative(_ creative: Swift.String?)
}
extension RevenueCat.StoreProduct {
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS, deprecated, introduced: 13.0, renamed: "eligiblePromotionalOffers()")
  @available(tvOS, deprecated, introduced: 13.0, renamed: "eligiblePromotionalOffers()")
  @available(watchOS, deprecated, introduced: 6.2, renamed: "eligiblePromotionalOffers()")
  @available(macOS, deprecated, introduced: 10.15, renamed: "eligiblePromotionalOffers()")
  @available(macCatalyst, deprecated, introduced: 13.0, renamed: "eligiblePromotionalOffers()")
  final public func getEligiblePromotionalOffers() async -> [RevenueCat.PromotionalOffer]
  #endif
}
extension RevenueCat.CustomerInfo {
  @available(*, deprecated, message: "use nonSubscriptionTransactions")
  @objc final public var nonConsumablePurchases: Swift.Set<Swift.String> {
    @objc get
  }
  @available(*, deprecated, renamed: "nonSubscriptions")
  @objc final public var nonSubscriptionTransactions: [RevenueCat.StoreTransaction] {
    @objc get
  }
}
extension RevenueCat.Configuration.Builder {
  @available(*, deprecated, message: "RevenueCat currently uses StoreKit 1 for purchases, as its stability in production scenarios has\nproven to be more performant than StoreKit 2.\n\nWe're collecting more data on the best approach, but StoreKit 1 vs StoreKit 2 is an implementation detail\nthat you shouldn't need to care about.\n\nSimply remove this method call to let RevenueCat decide for you which StoreKit implementation to use.")
  @objc dynamic public func with(usesStoreKit2IfAvailable: Swift.Bool) -> RevenueCat.Configuration.Builder
}
extension Dispatch.DispatchTimeInterval : Swift.Comparable {
  public static func < (lhs: Dispatch.DispatchTimeInterval, rhs: Dispatch.DispatchTimeInterval) -> Swift.Bool
}
extension Dispatch.DispatchTimeInterval : @unchecked Swift.Sendable {
}
@objc(RCPurchasesErrorCode) public enum ErrorCode : Swift.Int, Swift.Error {
  @objc(RCUnknownError) case unknownError = 0
  @objc(RCPurchaseCancelledError) case purchaseCancelledError = 1
  @objc(RCStoreProblemError) case storeProblemError = 2
  @objc(RCPurchaseNotAllowedError) case purchaseNotAllowedError = 3
  @objc(RCPurchaseInvalidError) case purchaseInvalidError = 4
  @objc(RCProductNotAvailableForPurchaseError) case productNotAvailableForPurchaseError = 5
  @objc(RCProductAlreadyPurchasedError) case productAlreadyPurchasedError = 6
  @objc(RCReceiptAlreadyInUseError) case receiptAlreadyInUseError = 7
  @objc(RCInvalidReceiptError) case invalidReceiptError = 8
  @objc(RCMissingReceiptFileError) case missingReceiptFileError = 9
  @objc(RCNetworkError) case networkError = 10
  @objc(RCInvalidCredentialsError) case invalidCredentialsError = 11
  @objc(RCUnexpectedBackendResponseError) case unexpectedBackendResponseError = 12
  @objc(RCReceiptInUseByOtherSubscriberError) case receiptInUseByOtherSubscriberError = 13
  @objc(RCInvalidAppUserIdError) case invalidAppUserIdError = 14
  @objc(RCOperationAlreadyInProgressForProductError) case operationAlreadyInProgressForProductError = 15
  @objc(RCUnknownBackendError) case unknownBackendError = 16
  @objc(RCInvalidAppleSubscriptionKeyError) case invalidAppleSubscriptionKeyError = 17
  @objc(RCIneligibleError) case ineligibleError = 18
  @objc(RCInsufficientPermissionsError) case insufficientPermissionsError = 19
  @objc(RCPaymentPendingError) case paymentPendingError = 20
  @objc(RCInvalidSubscriberAttributesError) case invalidSubscriberAttributesError = 21
  @objc(RCLogOutAnonymousUserError) case logOutAnonymousUserError = 22
  @objc(RCConfigurationError) case configurationError = 23
  @objc(RCUnsupportedError) case unsupportedError = 24
  @objc(RCEmptySubscriberAttributesError) case emptySubscriberAttributes = 25
  @objc(RCProductDiscountMissingIdentifierError) case productDiscountMissingIdentifierError = 26
  @objc(RCProductDiscountMissingSubscriptionGroupIdentifierError) case productDiscountMissingSubscriptionGroupIdentifierError = 28
  @objc(RCCustomerInfoError) case customerInfoError = 29
  @objc(RCSystemInfoError) case systemInfoError = 30
  @objc(RCBeginRefundRequestError) case beginRefundRequestError = 31
  @objc(RCProductRequestTimedOut) case productRequestTimedOut = 32
  @objc(RCAPIEndpointBlocked) case apiEndpointBlockedError = 33
  @objc(RCInvalidPromotionalOfferError) case invalidPromotionalOfferError = 34
  @objc(RCOfflineConnectionError) case offlineConnectionError = 35
  @objc(RCFeatureNotAvailableInCustomEntitlementsComputationMode) case featureNotAvailableInCustomEntitlementsComputationMode = 36
  @objc(RCSignatureVerificationFailed) case signatureVerificationFailed = 37
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public static var _nsErrorDomain: Swift.String {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
extension RevenueCat.ErrorCode : Swift.CaseIterable {
  public typealias AllCases = [RevenueCat.ErrorCode]
  public static var allCases: [RevenueCat.ErrorCode] {
    get
  }
}
extension RevenueCat.ErrorCode {
  public var description: Swift.String {
    get
  }
}
extension RevenueCat.ErrorCode : Foundation.CustomNSError {
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
}
@objc(RCRefundRequestStatus) public enum RefundRequestStatus : Swift.Int, Swift.Sendable {
  @objc(RCRefundRequestUserCancelled) case userCancelled = 0
  @objc(RCRefundRequestSuccess) case success
  @objc(RCRefundRequestError) case error
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc @_hasMissingDesignatedInitializers public class PurchasesReceiptParser : ObjectiveC.NSObject {
  public func parse(from receiptData: Foundation.Data) throws -> RevenueCat.AppleReceipt
  @objc deinit
}
extension RevenueCat.PurchasesReceiptParser {
  public func parse(base64String string: Swift.String) throws -> RevenueCat.AppleReceipt
}
extension RevenueCat.PurchasesReceiptParser : @unchecked Swift.Sendable {
}
extension RevenueCat.Purchases {
  @objc(RCPlatformInfo) final public class PlatformInfo : ObjectiveC.NSObject {
    @objc public init(flavor: Swift.String, version: Swift.String)
    @objc deinit
  }
  @objc public static var platformInfo: RevenueCat.Purchases.PlatformInfo?
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc(RCDangerousSettings) final public class DangerousSettings : ObjectiveC.NSObject {
  @objc final public let autoSyncPurchases: Swift.Bool
  @objc final public let customEntitlementComputation: Swift.Bool
  @objc override convenience dynamic public init()
  @objc convenience public init(autoSyncPurchases: Swift.Bool = true)
  @objc deinit
}
extension RevenueCat.DangerousSettings : Swift.Sendable {
}
@_hasMissingDesignatedInitializers @objc(RCCustomerInfo) final public class CustomerInfo : ObjectiveC.NSObject {
  @objc final public let entitlements: RevenueCat.EntitlementInfos
  @objc final public var activeSubscriptions: Swift.Set<Swift.String> {
    @objc get
  }
  @objc final public let allPurchasedProductIdentifiers: Swift.Set<Swift.String>
  @objc final public var latestExpirationDate: Foundation.Date? {
    @objc get
  }
  @objc final public let nonSubscriptions: [RevenueCat.NonSubscriptionTransaction]
  @objc final public let requestDate: Foundation.Date
  @objc final public let firstSeen: Foundation.Date
  @objc final public let originalAppUserId: Swift.String
  @objc final public let managementURL: Foundation.URL?
  @objc final public let originalPurchaseDate: Foundation.Date?
  @objc final public let originalApplicationVersion: Swift.String?
  @objc final public func expirationDate(forProductIdentifier productIdentifier: Swift.String) -> Foundation.Date?
  @objc final public func purchaseDate(forProductIdentifier productIdentifier: Swift.String) -> Foundation.Date?
  @objc final public func expirationDate(forEntitlement entitlementIdentifier: Swift.String) -> Foundation.Date?
  @objc final public func purchaseDate(forEntitlement entitlementIdentifier: Swift.String) -> Foundation.Date?
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  @objc override final public var hash: Swift.Int {
    @objc get
  }
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc deinit
}
extension RevenueCat.CustomerInfo : RevenueCat.RawDataContainer {
  @objc final public var rawData: [Swift.String : Any] {
    @objc get
  }
  public typealias Content = [Swift.String : Any]
}
extension RevenueCat.CustomerInfo : Swift.Sendable {
}
extension RevenueCat.CustomerInfo : Swift.Codable {
  convenience public init(from decoder: any Swift.Decoder) throws
  final public func encode(to encoder: any Swift.Encoder) throws
}
extension RevenueCat.AppleReceipt {
  public struct InAppPurchase : Swift.Equatable {
    public let quantity: Swift.Int
    public let productId: Swift.String
    public let transactionId: Swift.String
    public let originalTransactionId: Swift.String?
    public let productType: RevenueCat.AppleReceipt.InAppPurchase.ProductType
    public let purchaseDate: Foundation.Date
    public let originalPurchaseDate: Foundation.Date?
    public let expiresDate: Foundation.Date?
    public let cancellationDate: Foundation.Date?
    public let isInTrialPeriod: Swift.Bool?
    public let isInIntroOfferPeriod: Swift.Bool?
    public let webOrderLineItemId: Swift.Int64?
    public let promotionalOfferIdentifier: Swift.String?
    public static func == (a: RevenueCat.AppleReceipt.InAppPurchase, b: RevenueCat.AppleReceipt.InAppPurchase) -> Swift.Bool
  }
}
extension RevenueCat.AppleReceipt.InAppPurchase {
  public enum ProductType : Swift.Int {
    case unknown
    case nonConsumable
    case consumable
    case nonRenewingSubscription
    case autoRenewableSubscription
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
extension RevenueCat.AppleReceipt.InAppPurchase.ProductType : Swift.Sendable {
}
extension RevenueCat.AppleReceipt.InAppPurchase : Swift.Sendable {
}
extension RevenueCat.AppleReceipt.InAppPurchase.ProductType : Swift.Codable {
}
extension RevenueCat.AppleReceipt.InAppPurchase : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.AppleReceipt.InAppPurchase : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@objc(RCStore) public enum Store : Swift.Int {
  @objc(RCAppStore) case appStore = 0
  @objc(RCMacAppStore) case macAppStore = 1
  @objc(RCPlayStore) case playStore = 2
  @objc(RCStripe) case stripe = 3
  @objc(RCPromotional) case promotional = 4
  @objc(RCUnknownStore) case unknownStore = 5
  @objc(RCAmazon) case amazon = 6
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension RevenueCat.Store : Swift.CaseIterable {
  public typealias AllCases = [RevenueCat.Store]
  public static var allCases: [RevenueCat.Store] {
    get
  }
}
extension RevenueCat.Store : Swift.Sendable {
}
@objc(RCPeriodType) public enum PeriodType : Swift.Int {
  @objc(RCNormal) case normal = 0
  @objc(RCIntro) case intro = 1
  @objc(RCTrial) case trial = 2
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension RevenueCat.PeriodType : Swift.CaseIterable {
  public typealias AllCases = [RevenueCat.PeriodType]
  public static var allCases: [RevenueCat.PeriodType] {
    get
  }
}
extension RevenueCat.PeriodType : Swift.Sendable {
}
@_hasMissingDesignatedInitializers @objc(RCEntitlementInfo) final public class EntitlementInfo : ObjectiveC.NSObject {
  @objc final public var identifier: Swift.String {
    @objc get
  }
  @objc final public var isActive: Swift.Bool {
    @objc get
  }
  @objc final public var willRenew: Swift.Bool {
    @objc get
  }
  @objc final public var periodType: RevenueCat.PeriodType {
    @objc get
  }
  @objc final public var latestPurchaseDate: Foundation.Date? {
    @objc get
  }
  @objc final public var originalPurchaseDate: Foundation.Date? {
    @objc get
  }
  @objc final public var expirationDate: Foundation.Date? {
    @objc get
  }
  @objc final public var store: RevenueCat.Store {
    @objc get
  }
  @objc final public var productIdentifier: Swift.String {
    @objc get
  }
  @objc final public var productPlanIdentifier: Swift.String? {
    @objc get
  }
  @objc final public var isSandbox: Swift.Bool {
    @objc get
  }
  @objc final public var unsubscribeDetectedAt: Foundation.Date? {
    @objc get
  }
  @objc final public var billingIssueDetectedAt: Foundation.Date? {
    @objc get
  }
  @objc final public var ownershipType: RevenueCat.PurchaseOwnershipType {
    @objc get
  }
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
  @objc final public var verification: RevenueCat.VerificationResult {
    @objc get
  }
  @objc final public let rawData: [Swift.String : Any]
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  @objc override final public var hash: Swift.Int {
    @objc get
  }
  @objc deinit
}
extension RevenueCat.EntitlementInfo : RevenueCat.RawDataContainer {
  public typealias Content = [Swift.String : Any]
}
extension RevenueCat.EntitlementInfo : @unchecked Swift.Sendable {
}
extension RevenueCat.EntitlementInfo {
  @objc final public var isActiveInCurrentEnvironment: Swift.Bool {
    @objc get
  }
  @objc final public var isActiveInAnyEnvironment: Swift.Bool {
    @objc get
  }
}
extension RevenueCat.EntitlementInfo : Swift.Identifiable {
  final public var id: Swift.String {
    get
  }
  public typealias ID = Swift.String
}
public typealias VerboseLogHandler = (_ level: RevenueCat.LogLevel, _ message: Swift.String, _ file: Swift.String?, _ function: Swift.String?, _ line: Swift.UInt) -> Swift.Void
public typealias LogHandler = (_ level: RevenueCat.LogLevel, _ message: Swift.String) -> Swift.Void
extension RevenueCat.LogLevel : Swift.Comparable {
  public static func < (lhs: RevenueCat.LogLevel, rhs: RevenueCat.LogLevel) -> Swift.Bool
}
extension RevenueCat.PurchasesReceiptParser {
  public enum Error : Swift.Error {
    case dataObjectIdentifierMissing
    case asn1ParsingError(description: Swift.String)
    case receiptParsingError
    case inAppPurchaseParsingError
    case failedToDecodeBase64String
    case receiptNotPresent
    case failedToLoadLocalReceipt(any Swift.Error)
    case foundEmptyLocalReceipt
  }
}
extension RevenueCat.PurchasesReceiptParser.Error : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
@objc(RCLogLevel) public enum LogLevel : Swift.Int, Swift.CustomStringConvertible, Swift.CaseIterable, Swift.Sendable {
  case verbose = 4
  case debug = 0
  case info = 1
  case warn = 2
  case error = 3
  public var description: Swift.String {
    get
  }
  public init?(rawValue: Swift.Int)
  public typealias AllCases = [RevenueCat.LogLevel]
  public typealias RawValue = Swift.Int
  public static var allCases: [RevenueCat.LogLevel] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
@objc(RCPackageType) public enum PackageType : Swift.Int {
  case unknown = -2, custom, lifetime, annual, sixMonth, threeMonth, twoMonth, monthly, weekly
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension RevenueCat.PackageType : Swift.CaseIterable {
  public typealias AllCases = [RevenueCat.PackageType]
  public static var allCases: [RevenueCat.PackageType] {
    get
  }
}
extension RevenueCat.PackageType : Swift.Sendable {
}
extension RevenueCat.PackageType : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension RevenueCat.PackageType : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public typealias SK1Transaction = StoreKit.SKPaymentTransaction
@available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
public typealias SK2Transaction = StoreKit.Transaction
@_hasMissingDesignatedInitializers @objc(RCStoreTransaction) final public class StoreTransaction : ObjectiveC.NSObject {
  @objc final public var productIdentifier: Swift.String {
    @objc get
  }
  @objc final public var purchaseDate: Foundation.Date {
    @objc get
  }
  @objc final public var transactionIdentifier: Swift.String {
    @objc get
  }
  @objc final public var quantity: Swift.Int {
    @objc get
  }
  @objc final public var storefront: RevenueCat.Storefront? {
    @objc get
  }
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  @objc override final public var hash: Swift.Int {
    @objc get
  }
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc deinit
}
extension RevenueCat.StoreTransaction {
  @objc final public var sk1Transaction: RevenueCat.SK1Transaction? {
    @objc get
  }
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  final public var sk2Transaction: RevenueCat.SK2Transaction? {
    get
  }
}
extension RevenueCat.StoreTransaction : Swift.Identifiable {
  final public var id: Swift.String {
    get
  }
  public typealias ID = Swift.String
}
public protocol RawDataContainer {
  associatedtype Content
  var rawData: Self.Content { get }
}
public typealias PurchaseResultData = (transaction: RevenueCat.StoreTransaction?, customerInfo: RevenueCat.CustomerInfo, userCancelled: Swift.Bool)
#if compiler(>=5.3) && $Sendable
public typealias PurchaseCompletedBlock = @_Concurrency.MainActor @Sendable (RevenueCat.StoreTransaction?, RevenueCat.CustomerInfo?, RevenueCat.PublicError?, Swift.Bool) -> Swift.Void
#endif
public typealias StartPurchaseBlock = (@escaping RevenueCat.PurchaseCompletedBlock) -> Swift.Void
@_hasMissingDesignatedInitializers @objc(RCPurchases) final public class Purchases : ObjectiveC.NSObject, RevenueCat.PurchasesType, RevenueCat.PurchasesSwiftType {
  @objc(sharedPurchases) public static var shared: RevenueCat.Purchases {
    @objc get
  }
  @objc public static var isConfigured: Swift.Bool {
    @objc get
  }
  @objc final public var delegate: (any RevenueCat.PurchasesDelegate)? {
    @objc get
    @objc set
  }
  @objc public static var logLevel: RevenueCat.LogLevel {
    @objc get
    @objc set
  }
  @objc public static var proxyURL: Foundation.URL? {
    @objc get
    @objc set
  }
  @objc public static var forceUniversalAppStore: Swift.Bool {
    @objc get
    @objc set
  }
  @available(iOS 8.0, macOS 10.14, watchOS 6.2, macCatalyst 13.0, *)
  @objc public static var simulatesAskToBuyInSandbox: Swift.Bool {
    @objc get
    @objc set
  }
  @objc public static func canMakePayments() -> Swift.Bool
  @objc public static var logHandler: RevenueCat.LogHandler {
    @objc get
    @objc set
  }
  @objc public static var verboseLogHandler: RevenueCat.VerboseLogHandler {
    @objc get
    @objc set
  }
  @objc public static var verboseLogs: Swift.Bool {
    @objc get
    @objc set
  }
  @objc public static var frameworkVersion: Swift.String {
    @objc get
  }
  @objc final public let attribution: RevenueCat.Attribution
  @objc final public var finishTransactions: Swift.Bool {
    @objc get
    @objc set
  }
  @objc deinit
}
extension RevenueCat.Purchases {
  @objc final public var appUserID: Swift.String {
    @objc get
  }
  @objc final public var isAnonymous: Swift.Bool {
    @objc get
  }
  @objc final public func getOfferings(completion: @escaping (RevenueCat.Offerings?, RevenueCat.PublicError?) -> Swift.Void)
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
  @objc final public func offerings() async throws -> RevenueCat.Offerings
  #endif
  @objc final public var cachedOfferings: RevenueCat.Offerings? {
    @objc get
  }
}
extension RevenueCat.Purchases {
  final public func logIn(_ appUserID: Swift.StaticString, completion: @escaping (RevenueCat.CustomerInfo?, Swift.Bool, RevenueCat.PublicError?) -> Swift.Void)
  @_disfavoredOverload @objc(logIn:completion:) final public func logIn(_ appUserID: Swift.String, completion: @escaping (RevenueCat.CustomerInfo?, Swift.Bool, RevenueCat.PublicError?) -> Swift.Void)
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
  final public func logIn(_ appUserID: Swift.StaticString) async throws -> (customerInfo: RevenueCat.CustomerInfo, created: Swift.Bool)
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
  @_disfavoredOverload @objc final public func logIn(_ appUserID: Swift.String) async throws -> (customerInfo: RevenueCat.CustomerInfo, created: Swift.Bool)
  #endif
  @objc final public func logOut(completion: ((RevenueCat.CustomerInfo?, RevenueCat.PublicError?) -> Swift.Void)?)
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
  @objc final public func logOut() async throws -> RevenueCat.CustomerInfo
  #endif
}
extension RevenueCat.Purchases {
  @objc final public func getCustomerInfo(completion: @escaping (RevenueCat.CustomerInfo?, RevenueCat.PublicError?) -> Swift.Void)
  @objc final public func getCustomerInfo(fetchPolicy: RevenueCat.CacheFetchPolicy, completion: @escaping (RevenueCat.CustomerInfo?, RevenueCat.PublicError?) -> Swift.Void)
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
  @objc final public func customerInfo() async throws -> RevenueCat.CustomerInfo
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
  @objc final public func customerInfo(fetchPolicy: RevenueCat.CacheFetchPolicy) async throws -> RevenueCat.CustomerInfo
  #endif
  @objc final public var cachedCustomerInfo: RevenueCat.CustomerInfo? {
    @objc get
  }
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
  final public var customerInfoStream: _Concurrency.AsyncStream<RevenueCat.CustomerInfo> {
    get
  }
  @objc(getProductsWithIdentifiers:completion:) final public func getProducts(_ productIdentifiers: [Swift.String], completion: @escaping ([RevenueCat.StoreProduct]) -> Swift.Void)
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
  @objc final public func products(_ productIdentifiers: [Swift.String]) async -> [RevenueCat.StoreProduct]
  #endif
  #if compiler(>=5.3) && $Sendable
  @objc(purchaseProduct:withCompletion:) final public func purchase(product: RevenueCat.StoreProduct, completion: @escaping RevenueCat.PurchaseCompletedBlock)
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
  @objc final public func purchase(product: RevenueCat.StoreProduct) async throws -> RevenueCat.PurchaseResultData
  #endif
  #if compiler(>=5.3) && $Sendable
  @objc(purchasePackage:withCompletion:) final public func purchase(package: RevenueCat.Package, completion: @escaping RevenueCat.PurchaseCompletedBlock)
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
  @objc final public func purchase(package: RevenueCat.Package) async throws -> RevenueCat.PurchaseResultData
  #endif
  @objc final public func restorePurchases(completion: ((RevenueCat.CustomerInfo?, RevenueCat.PublicError?) -> Swift.Void)? = nil)
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
  @objc final public func restorePurchases() async throws -> RevenueCat.CustomerInfo
  #endif
  @objc final public func invalidateCustomerInfoCache()
  @objc final public func syncPurchases(completion: ((RevenueCat.CustomerInfo?, RevenueCat.PublicError?) -> Swift.Void)?)
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
  @objc final public func syncPurchases() async throws -> RevenueCat.CustomerInfo
  #endif
  #if compiler(>=5.3) && $Sendable
  @available(iOS 12.2, macOS 10.14.4, watchOS 6.2, macCatalyst 13.0, tvOS 12.2, *)
  @objc(purchaseProduct:withPromotionalOffer:completion:) final public func purchase(product: RevenueCat.StoreProduct, promotionalOffer: RevenueCat.PromotionalOffer, completion: @escaping RevenueCat.PurchaseCompletedBlock)
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
  @objc final public func purchase(product: RevenueCat.StoreProduct, promotionalOffer: RevenueCat.PromotionalOffer) async throws -> RevenueCat.PurchaseResultData
  #endif
  #if compiler(>=5.3) && $Sendable
  @available(iOS 12.2, macOS 10.14.4, watchOS 6.2, macCatalyst 13.0, tvOS 12.2, *)
  @objc(purchasePackage:withPromotionalOffer:completion:) final public func purchase(package: RevenueCat.Package, promotionalOffer: RevenueCat.PromotionalOffer, completion: @escaping RevenueCat.PurchaseCompletedBlock)
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
  @objc final public func purchase(package: RevenueCat.Package, promotionalOffer: RevenueCat.PromotionalOffer) async throws -> RevenueCat.PurchaseResultData
  #endif
  @objc(checkTrialOrIntroDiscountEligibility:completion:) final public func checkTrialOrIntroDiscountEligibility(productIdentifiers: [Swift.String], completion: @escaping ([Swift.String : RevenueCat.IntroEligibility]) -> Swift.Void)
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 13.0, tvOS 13.0, macOS 10.15, watchOS 6.2, *)
  @objc final public func checkTrialOrIntroDiscountEligibility(productIdentifiers: [Swift.String]) async -> [Swift.String : RevenueCat.IntroEligibility]
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 13.0, tvOS 13.0, macOS 10.15, watchOS 6.2, *)
  final public func checkTrialOrIntroDiscountEligibility(packages: [RevenueCat.Package]) async -> [RevenueCat.Package : RevenueCat.IntroEligibility]
  #endif
  @objc(checkTrialOrIntroDiscountEligibilityForProduct:completion:) final public func checkTrialOrIntroDiscountEligibility(product: RevenueCat.StoreProduct, completion: @escaping (RevenueCat.IntroEligibilityStatus) -> Swift.Void)
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 13.0, tvOS 13.0, macOS 10.15, watchOS 6.2, *)
  @objc final public func checkTrialOrIntroDiscountEligibility(product: RevenueCat.StoreProduct) async -> RevenueCat.IntroEligibilityStatus
  #endif
  @available(iOS 13.4, macCatalyst 13.4, *)
  @objc final public func showPriceConsentIfNeeded()
  @available(iOS 14.0, *)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @available(macOS, unavailable)
  @available(macCatalyst, unavailable)
  @objc final public func presentCodeRedemptionSheet()
  @available(iOS 12.2, macOS 10.14.4, macCatalyst 13.0, tvOS 12.2, watchOS 6.2, *)
  @objc(getPromotionalOfferForProductDiscount:withProduct:withCompletion:) final public func getPromotionalOffer(forProductDiscount discount: RevenueCat.StoreProductDiscount, product: RevenueCat.StoreProduct, completion: @escaping (RevenueCat.PromotionalOffer?, RevenueCat.PublicError?) -> Swift.Void)
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
  @objc final public func promotionalOffer(forProductDiscount discount: RevenueCat.StoreProductDiscount, product: RevenueCat.StoreProduct) async throws -> RevenueCat.PromotionalOffer
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
  @objc final public func eligiblePromotionalOffers(forProduct product: RevenueCat.StoreProduct) async -> [RevenueCat.PromotionalOffer]
  #endif
  @available(iOS 13.0, macOS 10.15, *)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @objc final public func showManageSubscriptions(completion: @escaping (RevenueCat.PublicError?) -> Swift.Void)
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 13.0, macOS 10.15, *)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @objc final public func showManageSubscriptions() async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 15.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @objc(beginRefundRequestForProduct:completion:) final public func beginRefundRequest(forProduct productID: Swift.String) async throws -> RevenueCat.RefundRequestStatus
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 15.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @objc(beginRefundRequestForEntitlement:completion:) final public func beginRefundRequest(forEntitlement entitlementID: Swift.String) async throws -> RevenueCat.RefundRequestStatus
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 15.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @objc(beginRefundRequestForActiveEntitlementWithCompletion:) final public func beginRefundRequestForActiveEntitlement() async throws -> RevenueCat.RefundRequestStatus
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 16.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  final public func showStoreMessages(for types: Swift.Set<RevenueCat.StoreMessageType> = Set(StoreMessageType.allCases)) async
  #endif
}
@available(iOS 15.0, tvOS 15.0, macOS 12.0, watchOS 8.0, *)
extension RevenueCat.Purchases {
  #if compiler(>=5.3) && $AsyncAwait
  final public func track(paywallEvent: RevenueCat.PaywallEvent) async
  #endif
}
extension RevenueCat.Purchases {
  @discardableResult
  @objc(configureWithConfiguration:) public static func configure(with configuration: RevenueCat.Configuration) -> RevenueCat.Purchases
  @discardableResult
  @objc(configureWithConfigurationBuilder:) public static func configure(with builder: RevenueCat.Configuration.Builder) -> RevenueCat.Purchases
  @discardableResult
  @objc(configureWithAPIKey:) public static func configure(withAPIKey apiKey: Swift.String) -> RevenueCat.Purchases
  @discardableResult
  @objc(configureWithAPIKey:appUserID:) public static func configure(withAPIKey apiKey: Swift.String, appUserID: Swift.String?) -> RevenueCat.Purchases
  @discardableResult
  @objc(configureWithAPIKey:appUserID:observerMode:) public static func configure(withAPIKey apiKey: Swift.String, appUserID: Swift.String?, observerMode: Swift.Bool) -> RevenueCat.Purchases
}
extension RevenueCat.Purchases {
  @available(*, deprecated, message: "use Purchases.logLevel instead")
  @objc public static var debugLogsEnabled: Swift.Bool {
    @objc get
    @objc set
  }
  @available(*, deprecated, message: "Configure behavior through the RevenueCat dashboard instead")
  @objc final public var allowSharingAppStoreAccount: Swift.Bool {
    @objc get
    @objc set
  }
  @available(*, deprecated, message: "Use the set<NetworkId> functions instead")
  @objc public static func addAttributionData(_ data: [Swift.String : Any], fromNetwork network: RevenueCat.AttributionNetwork)
  @available(*, deprecated, message: "Use the set<NetworkId> functions instead")
  @objc(addAttributionData:fromNetwork:forNetworkUserId:) public static func addAttributionData(_ data: [Swift.String : Any], from network: RevenueCat.AttributionNetwork, forNetworkUserId networkUserId: Swift.String?)
}
extension RevenueCat.Purchases : @unchecked Swift.Sendable {
}
@objc(RCSubscriptionPeriod) final public class SubscriptionPeriod : ObjectiveC.NSObject {
  @objc final public let value: Swift.Int
  @objc final public let unit: RevenueCat.SubscriptionPeriod.Unit
  public init(value: Swift.Int, unit: RevenueCat.SubscriptionPeriod.Unit)
  @objc(RCSubscriptionPeriodUnit) public enum Unit : Swift.Int {
    case day = 0
    case week = 1
    case month = 2
    case year = 3
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  @objc override final public var hash: Swift.Int {
    @objc get
  }
  @objc deinit
}
extension RevenueCat.SubscriptionPeriod {
  @available(iOS, unavailable, renamed: "value")
  @available(tvOS, unavailable, renamed: "value")
  @available(watchOS, unavailable, renamed: "value")
  @available(macOS, unavailable, renamed: "value")
  @objc final public var numberOfUnits: Swift.Int {
    @objc get
  }
}
extension RevenueCat.SubscriptionPeriod.Unit : Swift.Sendable {
}
extension RevenueCat.SubscriptionPeriod : Swift.Sendable {
}
extension RevenueCat.SubscriptionPeriod.Unit : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension RevenueCat.SubscriptionPeriod {
  @objc override final public var debugDescription: Swift.String {
    @objc get
  }
}
extension RevenueCat.SubscriptionPeriod.Unit : Swift.Encodable {
}
extension RevenueCat.SubscriptionPeriod : Swift.Encodable {
  final public func encode(to encoder: any Swift.Encoder) throws
}
@objc(RCPurchaseOwnershipType) public enum PurchaseOwnershipType : Swift.Int {
  case purchased = 0
  case familyShared = 1
  case unknown = 2
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension RevenueCat.PurchaseOwnershipType : Swift.CaseIterable {
  public typealias AllCases = [RevenueCat.PurchaseOwnershipType]
  public static var allCases: [RevenueCat.PurchaseOwnershipType] {
    get
  }
}
extension RevenueCat.PurchaseOwnershipType : Swift.Sendable {
}
public struct TestStoreProduct {
  public var localizedTitle: Swift.String
  public var price: Foundation.Decimal
  public var localizedPriceString: Swift.String
  public var productIdentifier: Swift.String
  public var productType: RevenueCat.StoreProduct.ProductType
  public var localizedDescription: Swift.String
  public var subscriptionGroupIdentifier: Swift.String?
  public var subscriptionPeriod: RevenueCat.SubscriptionPeriod?
  public var isFamilyShareable: Swift.Bool
  public var introductoryDiscount: RevenueCat.StoreProductDiscount?
  public var discounts: [RevenueCat.StoreProductDiscount]
  public var locale: Foundation.Locale
  public init(localizedTitle: Swift.String, price: Foundation.Decimal, localizedPriceString: Swift.String, productIdentifier: Swift.String, productType: RevenueCat.StoreProduct.ProductType, localizedDescription: Swift.String, subscriptionGroupIdentifier: Swift.String? = nil, subscriptionPeriod: RevenueCat.SubscriptionPeriod? = nil, isFamilyShareable: Swift.Bool = false, introductoryDiscount: RevenueCat.TestStoreProductDiscount? = nil, discounts: [RevenueCat.TestStoreProductDiscount] = [], locale: Foundation.Locale = .current)
}
extension RevenueCat.TestStoreProduct {
  public func toStoreProduct() -> RevenueCat.StoreProduct
}
extension RevenueCat.PaywallData {
  public var localizedConfiguration: RevenueCat.PaywallData.LocalizedConfiguration {
    get
  }
}
extension RevenueCat.PurchaseOwnershipType : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.PurchaseOwnershipType : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension RevenueCat.PeriodType : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.PeriodType : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension RevenueCat.PurchasesReceiptParser {
  @objc public static let `default`: RevenueCat.PurchasesReceiptParser
}
public struct AppleReceipt : Swift.Equatable {
  public let bundleId: Swift.String
  public let applicationVersion: Swift.String
  public let originalApplicationVersion: Swift.String?
  public let opaqueValue: Foundation.Data
  public let sha1Hash: Foundation.Data
  public let creationDate: Foundation.Date
  public let expirationDate: Foundation.Date?
  public let inAppPurchases: [RevenueCat.AppleReceipt.InAppPurchase]
  public static func == (a: RevenueCat.AppleReceipt, b: RevenueCat.AppleReceipt) -> Swift.Bool
}
extension RevenueCat.AppleReceipt : Swift.Sendable {
}
extension RevenueCat.AppleReceipt : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.AppleReceipt : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension RevenueCat.Store : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.Store : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
@_hasMissingDesignatedInitializers @objc(RCEntitlementInfos) final public class EntitlementInfos : ObjectiveC.NSObject {
  @objc final public let all: [Swift.String : RevenueCat.EntitlementInfo]
  @objc final public subscript(key: Swift.String) -> RevenueCat.EntitlementInfo? {
    @objc get
  }
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
  @objc final public var verification: RevenueCat.VerificationResult {
    @objc get
  }
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  @objc deinit
}
extension RevenueCat.EntitlementInfos {
  @objc final public var active: [Swift.String : RevenueCat.EntitlementInfo] {
    @objc get
  }
  @objc final public var activeInCurrentEnvironment: [Swift.String : RevenueCat.EntitlementInfo] {
    @objc get
  }
  @objc final public var activeInAnyEnvironment: [Swift.String : RevenueCat.EntitlementInfo] {
    @objc get
  }
}
extension RevenueCat.EntitlementInfos : Swift.Sendable {
}
@objc(RCStoreMessageType) public enum StoreMessageType : Swift.Int, Swift.CaseIterable, Swift.Sendable {
  case billingIssue = 0
  case priceIncreaseConsent
  case generic
  public init?(rawValue: Swift.Int)
  public typealias AllCases = [RevenueCat.StoreMessageType]
  public typealias RawValue = Swift.Int
  public static var allCases: [RevenueCat.StoreMessageType] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
@objc(RCPackage) final public class Package : ObjectiveC.NSObject {
  @objc final public let identifier: Swift.String
  @objc final public let packageType: RevenueCat.PackageType
  @objc final public let storeProduct: RevenueCat.StoreProduct
  @objc final public let offeringIdentifier: Swift.String
  @objc final public var localizedPriceString: Swift.String {
    @objc get
  }
  @objc final public var localizedIntroductoryPriceString: Swift.String? {
    @objc get
  }
  @objc public init(identifier: Swift.String, packageType: RevenueCat.PackageType, storeProduct: RevenueCat.StoreProduct, offeringIdentifier: Swift.String)
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  @objc override final public var hash: Swift.Int {
    @objc get
  }
  @objc deinit
}
@objc extension RevenueCat.Package {
  @objc public static func string(from packageType: RevenueCat.PackageType) -> Swift.String?
  @objc public static func packageType(from string: Swift.String) -> RevenueCat.PackageType
}
extension RevenueCat.Package : Swift.Identifiable {
  final public var id: Swift.String {
    get
  }
  public typealias ID = Swift.String
}
extension RevenueCat.Package : Swift.Sendable {
}
@_hasMissingDesignatedInitializers @objc(RCConfiguration) final public class Configuration : ObjectiveC.NSObject {
  @objc public static func builder(withAPIKey apiKey: Swift.String) -> RevenueCat.Configuration.Builder
  @objc(RCConfigurationBuilder) public class Builder : ObjectiveC.NSObject {
    @objc public init(withAPIKey apiKey: Swift.String)
    @objc public func with(apiKey: Swift.String) -> RevenueCat.Configuration.Builder
    @_disfavoredOverload @objc public func with(appUserID: Swift.String?) -> RevenueCat.Configuration.Builder
    public func with(appUserID: Swift.StaticString) -> RevenueCat.Configuration.Builder
    @objc public func with(observerMode: Swift.Bool) -> RevenueCat.Configuration.Builder
    @objc public func with(userDefaults: Foundation.UserDefaults) -> RevenueCat.Configuration.Builder
    @objc public func with(dangerousSettings: RevenueCat.DangerousSettings) -> RevenueCat.Configuration.Builder
    @objc public func with(networkTimeout: Foundation.TimeInterval) -> RevenueCat.Configuration.Builder
    @objc public func with(storeKit1Timeout: Foundation.TimeInterval) -> RevenueCat.Configuration.Builder
    @objc public func with(platformInfo: RevenueCat.Purchases.PlatformInfo) -> RevenueCat.Configuration.Builder
    @objc public func with(showStoreMessagesAutomatically: Swift.Bool) -> RevenueCat.Configuration.Builder
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
    @objc public func with(entitlementVerificationMode mode: RevenueCat.Configuration.EntitlementVerificationMode) -> RevenueCat.Configuration.Builder
    @objc public func build() -> RevenueCat.Configuration
    @objc deinit
  }
  @objc deinit
}
extension RevenueCat.Configuration {
  @objc(RCEntitlementVerificationMode) public enum EntitlementVerificationMode : Swift.Int {
    case disabled = 0
    case informational = 1
    @available(*, unavailable, message: "This will be supported in a future release")
    case enforced = 2
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
public enum PaywallViewMode {
  case fullScreen
  case footer
  case condensedFooter
  public static let `default`: RevenueCat.PaywallViewMode
  public static func == (a: RevenueCat.PaywallViewMode, b: RevenueCat.PaywallViewMode) -> Swift.Bool
}
extension RevenueCat.PaywallViewMode {
  public var isFullScreen: Swift.Bool {
    get
  }
}
extension RevenueCat.PaywallViewMode : Swift.CaseIterable {
  public typealias AllCases = [RevenueCat.PaywallViewMode]
  public static var allCases: [RevenueCat.PaywallViewMode] {
    get
  }
}
extension RevenueCat.PaywallViewMode : Swift.Sendable {
}
extension RevenueCat.PaywallViewMode : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension RevenueCat.PaywallViewMode : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct TestStoreProductDiscount {
  public var identifier: Swift.String
  public var price: Foundation.Decimal
  public var localizedPriceString: Swift.String
  public var paymentMode: RevenueCat.StoreProductDiscount.PaymentMode
  public var subscriptionPeriod: RevenueCat.SubscriptionPeriod
  public var numberOfPeriods: Swift.Int
  public var type: RevenueCat.StoreProductDiscount.DiscountType
  public init(identifier: Swift.String, price: Foundation.Decimal, localizedPriceString: Swift.String, paymentMode: RevenueCat.StoreProductDiscount.PaymentMode, subscriptionPeriod: RevenueCat.SubscriptionPeriod, numberOfPeriods: Swift.Int, type: RevenueCat.StoreProductDiscount.DiscountType)
}
extension RevenueCat.TestStoreProductDiscount {
  public func toStoreProductDiscount() -> RevenueCat.StoreProductDiscount
}
@objc(RCIntroEligibilityStatus) public enum IntroEligibilityStatus : Swift.Int {
  case unknown = 0
  case ineligible
  case eligible
  case noIntroOfferExists
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension RevenueCat.IntroEligibilityStatus : Swift.CaseIterable, Swift.Sendable {
  public typealias AllCases = [RevenueCat.IntroEligibilityStatus]
  public static var allCases: [RevenueCat.IntroEligibilityStatus] {
    get
  }
}
extension RevenueCat.IntroEligibilityStatus : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension RevenueCat.IntroEligibilityStatus {
  public var isEligible: Swift.Bool {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc(RCIntroEligibility) final public class IntroEligibility : ObjectiveC.NSObject {
  @objc final public let status: RevenueCat.IntroEligibilityStatus
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  @objc override final public var hash: Swift.Int {
    @objc get
  }
  @objc deinit
}
extension RevenueCat.IntroEligibility {
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc override final public var debugDescription: Swift.String {
    @objc get
  }
}
extension RevenueCat.IntroEligibility : Swift.Sendable {
}
@objc(RCCacheFetchPolicy) public enum CacheFetchPolicy : Swift.Int {
  case fromCacheOnly
  case fetchCurrent
  case notStaleCachedOrFetched
  case cachedOrFetched
  public static let `default`: RevenueCat.CacheFetchPolicy
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension RevenueCat.CacheFetchPolicy : Swift.Sendable {
}
@available(iOS 11.2, macOS 10.13.2, tvOS 11.2, watchOS 6.2, *)
public typealias SK1ProductDiscount = StoreKit.SKProductDiscount
@available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
public typealias SK2ProductDiscount = StoreKit.Product.SubscriptionOffer
@_hasMissingDesignatedInitializers @objc(RCStoreProductDiscount) final public class StoreProductDiscount : ObjectiveC.NSObject {
  @objc(RCPaymentMode) public enum PaymentMode : Swift.Int {
    case payAsYouGo = 0
    case payUpFront = 1
    case freeTrial = 2
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc(RCDiscountType) public enum DiscountType : Swift.Int {
    case introductory = 0
    case promotional = 1
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc final public var offerIdentifier: Swift.String? {
    @objc get
  }
  @objc final public var currencyCode: Swift.String? {
    @objc get
  }
  final public var price: Foundation.Decimal {
    get
  }
  @objc final public var localizedPriceString: Swift.String {
    @objc get
  }
  @objc final public var paymentMode: RevenueCat.StoreProductDiscount.PaymentMode {
    @objc get
  }
  @objc final public var subscriptionPeriod: RevenueCat.SubscriptionPeriod {
    @objc get
  }
  @objc final public var numberOfPeriods: Swift.Int {
    @objc get
  }
  @objc final public var type: RevenueCat.StoreProductDiscount.DiscountType {
    @objc get
  }
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  @objc override final public var hash: Swift.Int {
    @objc get
  }
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc deinit
}
extension RevenueCat.StoreProductDiscount : Swift.Sendable {
}
extension RevenueCat.StoreProductDiscount.PaymentMode : Swift.Sendable {
}
extension RevenueCat.StoreProductDiscount.DiscountType : Swift.Sendable {
}
extension RevenueCat.StoreProductDiscount {
  @objc(price) final public var priceDecimalNumber: Foundation.NSDecimalNumber {
    @objc get
  }
}
extension RevenueCat.StoreProductDiscount {
  public struct Data : Swift.Hashable {
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: RevenueCat.StoreProductDiscount.Data, b: RevenueCat.StoreProductDiscount.Data) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension RevenueCat.StoreProductDiscount {
  @available(iOS 12.2, macOS 10.14.4, tvOS 12.2, watchOS 6.2, *)
  @objc final public var sk1Discount: RevenueCat.SK1ProductDiscount? {
    @objc get
  }
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  final public var sk2Discount: RevenueCat.SK2ProductDiscount? {
    get
  }
}
extension RevenueCat.StoreProductDiscount : Swift.Encodable {
  final public func encode(to encoder: any Swift.Encoder) throws
}
extension RevenueCat.StoreProductDiscount.PaymentMode : Swift.Encodable {
}
extension RevenueCat.StoreProductDiscount : Swift.Identifiable {
  final public var id: RevenueCat.StoreProductDiscount.Data {
    get
  }
  public typealias ID = RevenueCat.StoreProductDiscount.Data
}
public struct PaywallColor {
  @frozen public enum ColorScheme : Swift.String {
    case light
    case dark
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public var stringRepresentation: Swift.String
  @available(iOS 13.0, tvOS 13.0, macOS 10.15, watchOS 6.2, *)
  public var underlyingColor: SwiftUI.Color {
    get
  }
}
extension RevenueCat.PaywallColor {
  public init(stringRepresentation: Swift.String) throws
  @available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
  public init(light: RevenueCat.PaywallColor, dark: RevenueCat.PaywallColor)
}
@available(iOS 13.0, tvOS 13.0, macOS 10.15, watchOS 6.2, *)
extension SwiftUI.Color {
  public var asPaywallColor: RevenueCat.PaywallColor {
    get
  }
}
extension RevenueCat.PaywallColor.ColorScheme : Swift.Equatable {
}
extension RevenueCat.PaywallColor.ColorScheme : Swift.Sendable {
}
extension RevenueCat.PaywallColor.ColorScheme : Swift.Codable {
}
extension RevenueCat.PaywallColor : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension RevenueCat.PaywallColor : Swift.Equatable {
  public static func == (lhs: RevenueCat.PaywallColor, rhs: RevenueCat.PaywallColor) -> Swift.Bool
}
extension RevenueCat.PaywallColor : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension RevenueCat.PaywallColor : Swift.Sendable {
}
extension RevenueCat.PaywallColor : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@objc(RCPurchasesDelegate) public protocol PurchasesDelegate : ObjectiveC.NSObjectProtocol {
  @available(swift, obsoleted: 1, renamed: "purchases(_:receivedUpdated:)")
  @available(iOS, obsoleted: 1)
  @available(macOS, obsoleted: 1)
  @available(tvOS, obsoleted: 1)
  @available(watchOS, obsoleted: 1)
  @objc(purchases:didReceiveUpdatedPurchaserInfo:) optional func purchases(_ purchases: RevenueCat.Purchases, didReceiveUpdated purchaserInfo: RevenueCat.CustomerInfo)
  @objc(purchases:receivedUpdatedCustomerInfo:) optional func purchases(_ purchases: RevenueCat.Purchases, receivedUpdated customerInfo: RevenueCat.CustomerInfo)
  @objc optional func purchases(_ purchases: RevenueCat.Purchases, readyForPromotedProduct product: RevenueCat.StoreProduct, purchase startPurchase: @escaping RevenueCat.StartPurchaseBlock)
  @available(iOS, obsoleted: 1, renamed: "purchases(_:readyForPromotedProduct:purchase:)")
  @available(tvOS, obsoleted: 1, renamed: "purchases(_:readyForPromotedProduct:purchase:)")
  @available(watchOS, obsoleted: 1, renamed: "purchases(_:readyForPromotedProduct:purchase:)")
  @available(macOS, obsoleted: 1, renamed: "purchases(_:readyForPromotedProduct:purchase:)")
  @available(macCatalyst, obsoleted: 1, renamed: "purchases(_:readyForPromotedProduct:purchase:)")
  @objc optional func purchases(_ purchases: RevenueCat.Purchases, shouldPurchasePromoProduct product: RevenueCat.StoreProduct, defermentBlock makeDeferredPurchase: @escaping RevenueCat.StartPurchaseBlock)
  @available(iOS 13.4, macCatalyst 13.4, *)
  @available(macOS, unavailable)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  @objc optional var shouldShowPriceConsent: Swift.Bool { get }
}
@objc(RCAttributionNetwork) public enum AttributionNetwork : Swift.Int {
  @available(*, deprecated, message: "use adServices")
  case appleSearchAds = 0
  case adjust = 1
  case appsFlyer = 2
  case branch = 3
  case tenjin = 4
  case facebook = 5
  case mParticle = 6
  case adServices = 7
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension RevenueCat.AttributionNetwork : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
public typealias PublicError = Foundation.NSError
@objc(RCPurchasesType) public protocol PurchasesType {
  @objc var appUserID: Swift.String { get }
  @objc var isAnonymous: Swift.Bool { get }
  @objc var finishTransactions: Swift.Bool { get set }
  @objc var delegate: (any RevenueCat.PurchasesDelegate)? { get set }
  @objc func logIn(_ appUserID: Swift.String, completion: @escaping (RevenueCat.CustomerInfo?, Swift.Bool, RevenueCat.PublicError?) -> Swift.Void)
  #if compiler(>=5.3) && $AsyncAwait
  @objc @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
  func logIn(_ appUserID: Swift.String) async throws -> (customerInfo: RevenueCat.CustomerInfo, created: Swift.Bool)
  #endif
  @objc func logOut(completion: ((RevenueCat.CustomerInfo?, RevenueCat.PublicError?) -> Swift.Void)?)
  #if compiler(>=5.3) && $AsyncAwait
  @objc @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
  func logOut() async throws -> RevenueCat.CustomerInfo
  #endif
  @objc func getCustomerInfo(completion: @escaping ((RevenueCat.CustomerInfo?, RevenueCat.PublicError?) -> Swift.Void))
  @objc func getCustomerInfo(fetchPolicy: RevenueCat.CacheFetchPolicy, completion: @escaping (RevenueCat.CustomerInfo?, RevenueCat.PublicError?) -> Swift.Void)
  #if compiler(>=5.3) && $AsyncAwait
  @objc @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
  func customerInfo() async throws -> RevenueCat.CustomerInfo
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @objc @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
  func customerInfo(fetchPolicy: RevenueCat.CacheFetchPolicy) async throws -> RevenueCat.CustomerInfo
  #endif
  @objc var cachedCustomerInfo: RevenueCat.CustomerInfo? { get }
  @objc func getOfferings(completion: @escaping ((RevenueCat.Offerings?, RevenueCat.PublicError?) -> Swift.Void))
  #if compiler(>=5.3) && $AsyncAwait
  @objc @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
  func offerings() async throws -> RevenueCat.Offerings
  #endif
  @objc var cachedOfferings: RevenueCat.Offerings? { get }
  @objc(getProductsWithIdentifiers:completion:) func getProducts(_ productIdentifiers: [Swift.String], completion: @escaping ([RevenueCat.StoreProduct]) -> Swift.Void)
  #if compiler(>=5.3) && $AsyncAwait
  @objc @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
  func products(_ productIdentifiers: [Swift.String]) async -> [RevenueCat.StoreProduct]
  #endif
  #if compiler(>=5.3) && $Sendable
  @objc(purchaseProduct:withCompletion:) func purchase(product: RevenueCat.StoreProduct, completion: @escaping RevenueCat.PurchaseCompletedBlock)
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @objc @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
  func purchase(product: RevenueCat.StoreProduct) async throws -> RevenueCat.PurchaseResultData
  #endif
  #if compiler(>=5.3) && $Sendable
  @objc(purchasePackage:withCompletion:) func purchase(package: RevenueCat.Package, completion: @escaping RevenueCat.PurchaseCompletedBlock)
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @objc @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
  func purchase(package: RevenueCat.Package) async throws -> RevenueCat.PurchaseResultData
  #endif
  @objc func invalidateCustomerInfoCache()
  @objc func restorePurchases(completion: ((RevenueCat.CustomerInfo?, RevenueCat.PublicError?) -> Swift.Void)?)
  #if compiler(>=5.3) && $AsyncAwait
  @objc @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
  func restorePurchases() async throws -> RevenueCat.CustomerInfo
  #endif
  @objc func syncPurchases(completion: ((RevenueCat.CustomerInfo?, RevenueCat.PublicError?) -> Swift.Void)?)
  #if compiler(>=5.3) && $AsyncAwait
  @objc @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
  func syncPurchases() async throws -> RevenueCat.CustomerInfo
  #endif
  #if compiler(>=5.3) && $Sendable
  @available(iOS 12.2, macOS 10.14.4, watchOS 6.2, macCatalyst 13.0, tvOS 12.2, *)
  @objc(purchaseProduct:withPromotionalOffer:completion:) func purchase(product: RevenueCat.StoreProduct, promotionalOffer: RevenueCat.PromotionalOffer, completion: @escaping RevenueCat.PurchaseCompletedBlock)
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @objc @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
  func purchase(product: RevenueCat.StoreProduct, promotionalOffer: RevenueCat.PromotionalOffer) async throws -> RevenueCat.PurchaseResultData
  #endif
  #if compiler(>=5.3) && $Sendable
  @available(iOS 12.2, macOS 10.14.4, watchOS 6.2, macCatalyst 13.0, tvOS 12.2, *)
  @objc(purchasePackage:withPromotionalOffer:completion:) func purchase(package: RevenueCat.Package, promotionalOffer: RevenueCat.PromotionalOffer, completion: @escaping RevenueCat.PurchaseCompletedBlock)
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @objc @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
  func purchase(package: RevenueCat.Package, promotionalOffer: RevenueCat.PromotionalOffer) async throws -> RevenueCat.PurchaseResultData
  #endif
  @objc(checkTrialOrIntroDiscountEligibility:completion:) func checkTrialOrIntroDiscountEligibility(productIdentifiers: [Swift.String], completion receiveEligibility: @escaping ([Swift.String : RevenueCat.IntroEligibility]) -> Swift.Void)
  #if compiler(>=5.3) && $AsyncAwait
  @objc @available(iOS 13.0, tvOS 13.0, macOS 10.15, watchOS 6.2, *)
  func checkTrialOrIntroDiscountEligibility(productIdentifiers: [Swift.String]) async -> [Swift.String : RevenueCat.IntroEligibility]
  #endif
  @objc(checkTrialOrIntroDiscountEligibilityForProduct:completion:) func checkTrialOrIntroDiscountEligibility(product: RevenueCat.StoreProduct, completion: @escaping (RevenueCat.IntroEligibilityStatus) -> Swift.Void)
  #if compiler(>=5.3) && $AsyncAwait
  @objc @available(iOS 13.0, tvOS 13.0, macOS 10.15, watchOS 6.2, *)
  func checkTrialOrIntroDiscountEligibility(product: RevenueCat.StoreProduct) async -> RevenueCat.IntroEligibilityStatus
  #endif
  @available(iOS 12.2, macOS 10.14.4, macCatalyst 13.0, tvOS 12.2, watchOS 6.2, *)
  @objc(getPromotionalOfferForProductDiscount:withProduct:withCompletion:) func getPromotionalOffer(forProductDiscount discount: RevenueCat.StoreProductDiscount, product: RevenueCat.StoreProduct, completion: @escaping ((RevenueCat.PromotionalOffer?, RevenueCat.PublicError?) -> Swift.Void))
  #if compiler(>=5.3) && $AsyncAwait
  @objc @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
  func promotionalOffer(forProductDiscount discount: RevenueCat.StoreProductDiscount, product: RevenueCat.StoreProduct) async throws -> RevenueCat.PromotionalOffer
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @objc @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
  func eligiblePromotionalOffers(forProduct product: RevenueCat.StoreProduct) async -> [RevenueCat.PromotionalOffer]
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 15.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @objc(beginRefundRequestForProduct:completion:) func beginRefundRequest(forProduct productID: Swift.String) async throws -> RevenueCat.RefundRequestStatus
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 15.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @objc(beginRefundRequestForEntitlement:completion:) func beginRefundRequest(forEntitlement entitlementID: Swift.String) async throws -> RevenueCat.RefundRequestStatus
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 15.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @objc(beginRefundRequestForActiveEntitlementWithCompletion:) func beginRefundRequestForActiveEntitlement() async throws -> RevenueCat.RefundRequestStatus
  #endif
  @objc @available(iOS 14.0, *)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @available(macOS, unavailable)
  @available(macCatalyst, unavailable)
  func presentCodeRedemptionSheet()
  @available(iOS 13.4, macCatalyst 13.4, *)
  @objc func showPriceConsentIfNeeded()
  @available(iOS 13.0, macOS 10.15, *)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @objc func showManageSubscriptions(completion: @escaping (RevenueCat.PublicError?) -> Swift.Void)
  #if compiler(>=5.3) && $AsyncAwait
  @objc @available(iOS 13.0, macOS 10.15, *)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  func showManageSubscriptions() async throws
  #endif
  @objc var attribution: RevenueCat.Attribution { get }
  @objc func setAttributes(_ attributes: [Swift.String : Swift.String])
  @objc @available(*, deprecated)
  var allowSharingAppStoreAccount: Swift.Bool { get set }
  @objc @available(*, deprecated)
  func setEmail(_ email: Swift.String?)
  @objc @available(*, deprecated)
  func setPhoneNumber(_ phoneNumber: Swift.String?)
  @objc @available(*, deprecated)
  func setDisplayName(_ displayName: Swift.String?)
  @objc @available(*, deprecated)
  func setPushToken(_ pushToken: Foundation.Data?)
  @objc @available(*, deprecated)
  func setPushTokenString(_ pushToken: Swift.String?)
  @objc @available(*, deprecated)
  func setAdjustID(_ adjustID: Swift.String?)
  @objc @available(*, deprecated)
  func setAppsflyerID(_ appsflyerID: Swift.String?)
  @objc @available(*, deprecated)
  func setFBAnonymousID(_ fbAnonymousID: Swift.String?)
  @objc @available(*, deprecated)
  func setMparticleID(_ mparticleID: Swift.String?)
  @objc @available(*, deprecated)
  func setOnesignalID(_ onesignalID: Swift.String?)
  @objc @available(*, deprecated)
  func setMediaSource(_ mediaSource: Swift.String?)
  @objc @available(*, deprecated)
  func setCampaign(_ campaign: Swift.String?)
  @objc @available(*, deprecated)
  func setAdGroup(_ adGroup: Swift.String?)
  @objc @available(*, deprecated)
  func setAd(_ value: Swift.String?)
  @objc @available(*, deprecated)
  func setKeyword(_ keyword: Swift.String?)
  @objc @available(*, deprecated)
  func setCreative(_ creative: Swift.String?)
  @objc @available(*, deprecated)
  func setCleverTapID(_ cleverTapID: Swift.String?)
  @objc @available(*, deprecated)
  func setMixpanelDistinctID(_ mixpanelDistinctID: Swift.String?)
  @objc @available(*, deprecated)
  func setFirebaseAppInstanceID(_ firebaseAppInstanceID: Swift.String?)
  @objc @available(*, deprecated)
  func collectDeviceIdentifiers()
}
public protocol PurchasesSwiftType : AnyObject {
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
  var customerInfoStream: _Concurrency.AsyncStream<RevenueCat.CustomerInfo> { get }
  @available(iOS 15.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  func beginRefundRequest(forProduct productID: Swift.String, completion: @escaping (Swift.Result<RevenueCat.RefundRequestStatus, RevenueCat.PublicError>) -> Swift.Void)
  @available(iOS 15.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  func beginRefundRequest(forEntitlement entitlementID: Swift.String, completion: @escaping (Swift.Result<RevenueCat.RefundRequestStatus, RevenueCat.PublicError>) -> Swift.Void)
  @available(iOS 15.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  func beginRefundRequestForActiveEntitlement(completion: @escaping (Swift.Result<RevenueCat.RefundRequestStatus, RevenueCat.PublicError>) -> Swift.Void)
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 16.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  func showStoreMessages(for types: Swift.Set<RevenueCat.StoreMessageType>) async
  #endif
}
public typealias SK1Product = StoreKit.SKProduct
@available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
public typealias SK2Product = StoreKit.Product
@_hasMissingDesignatedInitializers @objc(RCStoreProduct) final public class StoreProduct : ObjectiveC.NSObject {
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  @objc override final public var hash: Swift.Int {
    @objc get
  }
  @objc final public var productType: RevenueCat.StoreProduct.ProductType {
    @objc get
  }
  @objc final public var productCategory: RevenueCat.StoreProduct.ProductCategory {
    @objc get
  }
  @objc final public var localizedDescription: Swift.String {
    @objc get
  }
  @objc final public var localizedTitle: Swift.String {
    @objc get
  }
  @objc final public var currencyCode: Swift.String? {
    @objc get
  }
  final public var price: Foundation.Decimal {
    get
  }
  @objc final public var localizedPriceString: Swift.String {
    @objc get
  }
  @objc final public var productIdentifier: Swift.String {
    @objc get
  }
  @available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
  @objc final public var isFamilyShareable: Swift.Bool {
    @objc get
  }
  @available(iOS 12.0, macCatalyst 13.0, tvOS 12.0, macOS 10.14, watchOS 6.2, *)
  @objc final public var subscriptionGroupIdentifier: Swift.String? {
    @objc get
  }
  @objc final public var priceFormatter: Foundation.NumberFormatter? {
    @objc get
  }
  @available(iOS 11.2, macOS 10.13.2, tvOS 11.2, watchOS 6.2, *)
  @objc final public var subscriptionPeriod: RevenueCat.SubscriptionPeriod? {
    @objc get
  }
  @available(iOS 11.2, macOS 10.13.2, tvOS 11.2, watchOS 6.2, *)
  @objc final public var introductoryDiscount: RevenueCat.StoreProductDiscount? {
    @objc get
  }
  @available(iOS 12.2, macOS 10.14.4, tvOS 12.2, watchOS 6.2, *)
  @objc final public var discounts: [RevenueCat.StoreProductDiscount] {
    @objc get
  }
  @objc deinit
}
extension RevenueCat.StoreProduct {
  @objc(price) final public var priceDecimalNumber: Foundation.NSDecimalNumber {
    @objc get
  }
  @available(iOS 11.2, macOS 10.13.2, tvOS 11.2, watchOS 6.2, *)
  @objc final public var pricePerMonth: Foundation.NSDecimalNumber? {
    @objc get
  }
  @available(iOS 11.2, macOS 10.13.2, tvOS 11.2, watchOS 6.2, *)
  @objc final public var pricePerYear: Foundation.NSDecimalNumber? {
    @objc get
  }
  @objc final public var localizedIntroductoryPriceString: Swift.String? {
    @objc get
  }
}
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
extension RevenueCat.StoreProduct {
  #if compiler(>=5.3) && $AsyncAwait
  final public func eligiblePromotionalOffers() async -> [RevenueCat.PromotionalOffer]
  #endif
}
extension RevenueCat.StoreProduct {
  @objc convenience dynamic public init(sk1Product: RevenueCat.SK1Product)
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  convenience public init(sk2Product: RevenueCat.SK2Product)
  @objc final public var sk1Product: RevenueCat.SK1Product? {
    @objc get
  }
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  final public var sk2Product: RevenueCat.SK2Product? {
    get
  }
}
extension RevenueCat.StoreProduct {
  @available(iOS, unavailable, introduced: 11.2, renamed: "introductoryDiscount", message: "Use StoreProductDiscount instead")
  @available(tvOS, unavailable, introduced: 11.2, renamed: "introductoryDiscount", message: "Use StoreProductDiscount instead")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "introductoryDiscount", message: "Use StoreProductDiscount instead")
  @available(macOS, unavailable, introduced: 10.13.2, renamed: "introductoryDiscount", message: "Use StoreProductDiscount instead")
  @objc final public var introductoryPrice: StoreKit.SKProductDiscount? {
    @objc get
  }
  @available(iOS, unavailable, message: "Use localizedPriceString instead")
  @available(tvOS, unavailable, message: "Use localizedPriceString instead")
  @available(watchOS, unavailable, message: "Use localizedPriceString instead")
  @available(macOS, unavailable, message: "Use localizedPriceString instead")
  @objc final public var priceLocale: Foundation.Locale {
    @objc get
  }
}
extension RevenueCat.VerificationResult : Swift.Equatable {}
extension RevenueCat.VerificationResult : Swift.Hashable {}
extension RevenueCat.VerificationResult : Swift.RawRepresentable {}
extension RevenueCat.StoreProduct : Swift.Sendable {}
extension RevenueCat.StoreProduct.ProductCategory : Swift.Equatable {}
extension RevenueCat.StoreProduct.ProductCategory : Swift.Hashable {}
extension RevenueCat.StoreProduct.ProductCategory : Swift.RawRepresentable {}
extension RevenueCat.StoreProduct.ProductType : Swift.Equatable {}
extension RevenueCat.StoreProduct.ProductType : Swift.Hashable {}
extension RevenueCat.StoreProduct.ProductType : Swift.RawRepresentable {}
extension RevenueCat.StoreTransaction : Swift.Sendable {}
extension RevenueCat.StoreProductDiscount.PaymentMode : Swift.Equatable {}
extension RevenueCat.StoreProductDiscount.PaymentMode : Swift.Hashable {}
extension RevenueCat.StoreProductDiscount.PaymentMode : Swift.RawRepresentable {}
extension RevenueCat.ErrorCode : Swift.Equatable {}
extension RevenueCat.ErrorCode : Swift.Hashable {}
extension RevenueCat.ErrorCode : Swift.RawRepresentable {}
extension RevenueCat.ErrorCode : Swift.CustomStringConvertible {}
extension RevenueCat.RefundRequestStatus : Swift.Equatable {}
extension RevenueCat.RefundRequestStatus : Swift.Hashable {}
extension RevenueCat.RefundRequestStatus : Swift.RawRepresentable {}
extension RevenueCat.AppleReceipt.InAppPurchase.ProductType : Swift.Equatable {}
extension RevenueCat.AppleReceipt.InAppPurchase.ProductType : Swift.Hashable {}
extension RevenueCat.AppleReceipt.InAppPurchase.ProductType : Swift.RawRepresentable {}
extension RevenueCat.Store : Swift.Equatable {}
extension RevenueCat.Store : Swift.Hashable {}
extension RevenueCat.Store : Swift.RawRepresentable {}
extension RevenueCat.PeriodType : Swift.Equatable {}
extension RevenueCat.PeriodType : Swift.Hashable {}
extension RevenueCat.PeriodType : Swift.RawRepresentable {}
extension RevenueCat.LogLevel : Swift.Hashable {}
extension RevenueCat.LogLevel : Swift.RawRepresentable {}
extension RevenueCat.PackageType : Swift.Equatable {}
extension RevenueCat.PackageType : Swift.Hashable {}
extension RevenueCat.PackageType : Swift.RawRepresentable {}
extension RevenueCat.SubscriptionPeriod.Unit : Swift.Equatable {}
extension RevenueCat.SubscriptionPeriod.Unit : Swift.Hashable {}
extension RevenueCat.SubscriptionPeriod.Unit : Swift.RawRepresentable {}
extension RevenueCat.PurchaseOwnershipType : Swift.Equatable {}
extension RevenueCat.PurchaseOwnershipType : Swift.Hashable {}
extension RevenueCat.PurchaseOwnershipType : Swift.RawRepresentable {}
extension RevenueCat.TestStoreProduct : Swift.Sendable {}
extension RevenueCat.StoreMessageType : Swift.Equatable {}
extension RevenueCat.StoreMessageType : Swift.Hashable {}
extension RevenueCat.StoreMessageType : Swift.RawRepresentable {}
extension RevenueCat.Configuration.EntitlementVerificationMode : Swift.Equatable {}
extension RevenueCat.Configuration.EntitlementVerificationMode : Swift.Hashable {}
extension RevenueCat.Configuration.EntitlementVerificationMode : Swift.RawRepresentable {}
extension RevenueCat.TestStoreProductDiscount : Swift.Sendable {}
extension RevenueCat.IntroEligibilityStatus : Swift.Equatable {}
extension RevenueCat.IntroEligibilityStatus : Swift.Hashable {}
extension RevenueCat.IntroEligibilityStatus : Swift.RawRepresentable {}
extension RevenueCat.CacheFetchPolicy : Swift.Equatable {}
extension RevenueCat.CacheFetchPolicy : Swift.Hashable {}
extension RevenueCat.CacheFetchPolicy : Swift.RawRepresentable {}
extension RevenueCat.StoreProductDiscount.DiscountType : Swift.Equatable {}
extension RevenueCat.StoreProductDiscount.DiscountType : Swift.Hashable {}
extension RevenueCat.StoreProductDiscount.DiscountType : Swift.RawRepresentable {}
extension RevenueCat.PaywallColor.ColorScheme : Swift.Hashable {}
extension RevenueCat.PaywallColor.ColorScheme : Swift.RawRepresentable {}
extension RevenueCat.AttributionNetwork : Swift.Equatable {}
extension RevenueCat.AttributionNetwork : Swift.Hashable {}
extension RevenueCat.AttributionNetwork : Swift.RawRepresentable {}
